<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Apps · PackageCompiler</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PackageCompiler</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../sysimages/">Sysimages</a></li><li class="is-active"><a class="tocitem" href>Apps</a><ul class="internal"><li><a class="tocitem" href="#Relocatability-1"><span>Relocatability</span></a></li><li><a class="tocitem" href="#Creating-an-app-1"><span>Creating an app</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/ohmyrepl/">Creating a sysimage with OhMyREPL</a></li><li><a class="tocitem" href="../examples/plots/">Creating a sysimage for fast plotting with Plots.jl</a></li></ul></li><li><span class="tocitem">PackageCompiler - the manual way</span><ul><li><a class="tocitem" href="../devdocs/intro/">Introduction</a></li><li><a class="tocitem" href="../devdocs/sysimages_part_1/">Creating a sysimage</a></li><li><a class="tocitem" href="../devdocs/binaries_part_2/">Creating a binary from Julia code</a></li><li><a class="tocitem" href="../devdocs/relocatable_part_3/">Relocatable apps</a></li></ul></li><li><a class="tocitem" href="../refs/">References</a></li><li><a class="tocitem" href="../upgrade/">Upgrade notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Apps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Apps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/PackageCompiler.jl/blob/master/docs/src/apps.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Apps-1"><a class="docs-heading-anchor" href="#Apps-1">Apps</a><a class="docs-heading-anchor-permalink" href="#Apps-1" title="Permalink"></a></h1><p>With an &quot;app&quot; we here mean a &quot;bundle&quot; of files where one of these files is an executable and where this bundle can be sent to another machine while still allowing the executable to run.</p><p>Use-cases for Julia-apps are for example when one wants to provide some kind of functionality where the fact that the code was written in Julia is just an implementation detail and where requiring the user to download and use Julia to run the code would be a distraction. There is also no need to provide the original Julia source code for apps since everything gets baked into the sysimage.</p><h2 id="Relocatability-1"><a class="docs-heading-anchor" href="#Relocatability-1">Relocatability</a><a class="docs-heading-anchor-permalink" href="#Relocatability-1" title="Permalink"></a></h2><p>Since we want to send the app to other machines the app we create must be &quot;relocatable&quot;.  With an app being relocatable we mean it does not rely on specifics of the machine where the app was created.  Relocatability is not an absolute measure, most apps assume some properties of the machine they will run on, like what operating system is installed and the presence of graphics drivers if one wants to show graphics. On the other hand, embedding things into the app that is most likely unique to the machine, such as absolute paths to libraries, means that the application almost surely will not run properly on another machine.</p><p>For something to be relocatable, everything that it depends on must also be relocatable.  In the case of an app, the app itself and all the Julia packages it depends on must also relocatable. This is a bit of an issue because the Julia package ecosystem has rarely given much thought to relocatability since creating &quot;apps&quot; has not been common.</p><p>The main problem with relocatability of Julia packages is that many packages are encoding fundamentally non-relocatable information <em>into the source code</em>. As an example, many packages tend to use a <code>build.jl</code> file (which runs when the package is first installed) that looks something like:</p><pre><code class="language-julia">lib_path = find_library(&quot;libfoo&quot;)
write(&quot;deps.jl&quot;, &quot;const LIBFOO_PATH = $(repr(lib_path))&quot;)</code></pre><p>The main package file then contains:</p><pre><code class="language-julia">module Package

if !isfile(&quot;../build/deps.jl&quot;)
    error(&quot;run Pkg.build(\&quot;Package\&quot;) to re-build Package&quot;)
end
include(&quot;../build/deps.jl&quot;)
function __init__()
    libfoo = Libdl.dlopen(LIBFOO_PATH)
end

...

end # module</code></pre><p>The absolute path to <code>lib_path</code> that <code>find_library</code> found is thus effectively included into the source code of the package. Arguably, the whole build system in Julia is inherently non-relocatable because it runs when the package is being installed which is a concept that does not make sense when distributing an app.</p><p>Some packages do need to call into external libraries and use external binaries so the question then arises: &quot;how are these packages supposed to do this in a relocatable way?&quot;  The answer is to use the &quot;artifact system&quot; introduced in Julia 1.3, and described in the following <a href="https://julialang.org/blog/2019/11/artifacts">blog post</a>. The artifact system is a declarative way of downloading and using &quot;external files&quot; like binaries and libraries.  How this is used in practice is described later.</p><h2 id="Creating-an-app-1"><a class="docs-heading-anchor" href="#Creating-an-app-1">Creating an app</a><a class="docs-heading-anchor-permalink" href="#Creating-an-app-1" title="Permalink"></a></h2><p>The source of an app is a package with a project and manifest file. It should define a function with the signature</p><pre><code class="language-julia">function julia_main()::Cint
  # do something based on ARGS?
  return 0 # if things finished successfully
end</code></pre><p>which will be the entry point of the app (the function that runs when the executable in the app is run). A skeleton of an app to start working from can be found at https://github.com/JuliaLang/PackageCompiler.jl/tree/master/examples/MyApp.</p><p>Regarding relocatability, PackageCompiler provides a function <a href="../refs/#PackageCompiler.audit_app"><code>audit_app(app_dir::String)</code></a> that tries to find common problems with relocatability in the app.</p><p>The app is then compiled using the <a href="../refs/#PackageCompiler.create_app"><code>create_app</code></a> function that takes a path to the source code of the app and the destination where the app should be compiled to. This will bundle all required libraries for the app to run on another machine where the same Julia that created the app can run.  As an example, in the code snippet below, the example app linked above is compiled and run:</p><pre><code class="language-none">~/PackageCompiler.jl/examples
❯ julia -q --project

julia&gt; using PackageCompiler

julia&gt; create_app(&quot;MyApp&quot;, &quot;MyAppCompiled&quot;)
[ Info: PackageCompiler: creating base system image (incremental=false), this might take a while...
[ Info: PackageCompiler: creating system image object file, this might take a while...

julia&gt; exit()

~/PackageCompiler.jl/examples
❯ MyAppCompiled/bin/MyApp
ARGS = [&quot;foo&quot;, &quot;bar&quot;]
Base.PROGRAM_FILE = &quot;MyAppCompiled/bin/MyApp&quot;
...
Hello, World!

Running the artifact
The result of 2*5^2 - 10 == 40.000000
unsafe_string((Base.JLOptions()).image_file) = &quot;/Users/kristoffer/PackageCompiler.jl/examples/MyAppCompiled/bin/MyApp.dylib&quot;
Example.domath(5) = 10</code></pre><p>The resulting executable is found in the <code>bin</code> folder in the compiled app directory.  The compiled app directory <code>MyAppCompiled</code> could now be put into an archive and sent to another machine or an installer could be wrapped around the directory, perhaps providing a better user experience than just an archive of files.</p><h3 id="Precompilation-1"><a class="docs-heading-anchor" href="#Precompilation-1">Precompilation</a><a class="docs-heading-anchor-permalink" href="#Precompilation-1" title="Permalink"></a></h3><p>In the same way as files for precompilation could be given when creating sysimages, the same keyword arguments are used to add precompilation to apps.</p><h3 id="Incremental-vs-non-incremental-sysimage-1"><a class="docs-heading-anchor" href="#Incremental-vs-non-incremental-sysimage-1">Incremental vs non-incremental sysimage</a><a class="docs-heading-anchor-permalink" href="#Incremental-vs-non-incremental-sysimage-1" title="Permalink"></a></h3><p>In the section about creating sysimages, there was a short discussion about incremental vs non-incremental sysimages. In short, an incremental sysimage is built on top of another sysimage, while a non-incremental is created from scratch. For sysimages, it makes sense to use an incremental sysimage built on top of Julia&#39;s default sysimage since we wanted the benefit of having a responsive REPL that it provides.  For apps, this is no longer the case, the sysimage is not meant to be used when working interactively, it only needs to be specialized for the specific app.  Therefore, by default, <code>incremental=false</code> is used for <code>create_app</code>. If, for some reason, one wants an incremental sysimage, <code>incremental=true</code> could be passed to <code>create_app</code>.  With the example app, a non-incremental sysimage is about 70MB smaller than the default sysimage.</p><h3 id="Filtering-stdlibs-1"><a class="docs-heading-anchor" href="#Filtering-stdlibs-1">Filtering stdlibs</a><a class="docs-heading-anchor-permalink" href="#Filtering-stdlibs-1" title="Permalink"></a></h3><p>By default, all standard libraries are included in the sysimage.  It is possible to only include those standard libraries that the project needs.  This is done by passing the keyword argument <code>filter_stdlibs=true</code> to <code>create_app</code>. This causes the sysimage to be smaller, and possibly load faster.  The reason this is not the default is that it is possible to &quot;accidentally&quot; depend on a standard library without it being reflected in the Project file.  For example, it is possible to call <code>rand()</code> from a package without depending on Random, even though that is where the method is defined. If Random was excluded from the sysimage that call would then error. The same thing is true for e.g. matrix multiplication, <code>rand(3,3) * rand(3,3)</code> requires both the standard libraries <code>LinearAlgebra</code> and <code>Random</code> This is because these standard libraries do &quot;type-piracy&quot; so just loading those packages can cause code to change behavior.</p><p>Nevertheless, the option is there to use. Just make sure to properly test the app with the resulting sysimage.</p><h3 id="Artifacts-1"><a class="docs-heading-anchor" href="#Artifacts-1">Artifacts</a><a class="docs-heading-anchor-permalink" href="#Artifacts-1" title="Permalink"></a></h3><p>The way to depend on external libraries or binaries when creating apps is by using the <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/">artifact system</a>. PackageCompiler will bundle all artifacts needed by the project, and set up things so that they can be found during runtime on other machines.</p><p>The example app uses the artifact system to depend on a very simple toy binary that does some simple arithmetic. It is instructive to see how the <a href="https://github.com/JuliaLang/PackageCompiler.jl/blob/master/examples/MyApp/Artifacts.toml">artifact file</a> is <a href="https://github.com/JuliaLang/PackageCompiler.jl/blob/d722a3d91abe328ebd239e2f45660be35263ebe1/examples/MyApp/src/MyApp.jl#L7-L8">used in the source</a>.</p><h3 id="Reverse-engineering-the-compiled-app-1"><a class="docs-heading-anchor" href="#Reverse-engineering-the-compiled-app-1">Reverse engineering the compiled app</a><a class="docs-heading-anchor-permalink" href="#Reverse-engineering-the-compiled-app-1" title="Permalink"></a></h3><p>While the created app is relocatable and no source code is bundled with it, there are still some things about the build machine and the source code that can be &quot;reverse engineered&quot;.</p><h4 id="Absolute-paths-of-build-machine-1"><a class="docs-heading-anchor" href="#Absolute-paths-of-build-machine-1">Absolute paths of build machine</a><a class="docs-heading-anchor-permalink" href="#Absolute-paths-of-build-machine-1" title="Permalink"></a></h4><p>Julia records the paths and line-numbers for methods when they are getting compiled.  These get cached into the sysimage and can be found e.g. by dumping all strings in the sysimage:</p><pre><code class="language-none">~/PackageCompiler.jl/examples/MyAppCompiled/bin
❯ strings MyApp.so | grep MyApp
MyApp
/home/kc/PackageCompiler.jl/examples/MyApp/
MyApp
/home/kc/PackageCompiler.jl/examples/MyApp/src/MyApp.jl
/home/kc/PackageCompiler.jl/examples/MyApp/src
MyApp.jl
/home/kc/PackageCompiler.jl/examples/MyApp/src/MyApp.jl</code></pre><p>This is a problem that the Julia standard libraries themselves have:</p><pre><code class="language-julia-repl">julia&gt; @which rand()
rand() in Random at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Random/src/Random.jl:256</code></pre><h4 id="Using-reflection-and-finding-lowered-code-1"><a class="docs-heading-anchor" href="#Using-reflection-and-finding-lowered-code-1">Using reflection and finding lowered code</a><a class="docs-heading-anchor-permalink" href="#Using-reflection-and-finding-lowered-code-1" title="Permalink"></a></h4><p>There is nothing preventing someone from starting Julia with the sysimage that comes with the app.  And while the source code is not available one can read the &quot;lowered code&quot; and use reflection to find things like the name of fields in structs and global variables etc:</p><pre><code class="language-julia-repl">~/PackageCompiler.jl/examples/MyAppCompiled/bin kc/docs_apps*
❯ julia -q -JMyApp.so
julia&gt; MyApp = Base.loaded_modules[Base.PkgId(Base.UUID(&quot;f943f3d7-887a-4ed5-b0c0-a1d6899aa8f5&quot;), &quot;MyApp&quot;)]
MyApp

julia&gt; names(MyApp; all=true)
10-element Array{Symbol,1}:
 Symbol(&quot;#eval&quot;)
 Symbol(&quot;#include&quot;)
 Symbol(&quot;#julia_main&quot;)
 Symbol(&quot;#real_main&quot;)
 :MyApp
 :eval
 :include
 :julia_main
 :real_main
 :socrates

julia&gt; @code_lowered MyApp.real_main()
CodeInfo(
1 ─ %1  = MyApp.ARGS
│         value@_2 = %1
│   %3  = Base.repr(%1)
│         Base.println(&quot;ARGS = &quot;, %3)
│         value@_2
│   %6  = Base.PROGRAM_FILE
│         value@_3 = %6
│   %8  = Base.repr(%6)
│         Base.println(&quot;Base.PROGRAM_FILE = &quot;, %8)
│         value@_3
│   %11 = MyApp.DEPOT_PATH</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sysimages/">« Sysimages</a><a class="docs-footer-nextpage" href="../examples/ohmyrepl/">Creating a sysimage with OhMyREPL »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 February 2020 18:04">Tuesday 25 February 2020</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
