<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating a sysimage · PackageCompiler</title><meta name="title" content="Creating a sysimage · PackageCompiler"/><meta property="og:title" content="Creating a sysimage · PackageCompiler"/><meta property="twitter:title" content="Creating a sysimage · PackageCompiler"/><meta name="description" content="Documentation for PackageCompiler."/><meta property="og:description" content="Documentation for PackageCompiler."/><meta property="twitter:description" content="Documentation for PackageCompiler."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PackageCompiler</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../sysimages.html">Sysimages</a></li><li><a class="tocitem" href="../apps.html">Apps</a></li><li><a class="tocitem" href="../libs.html">Libraries</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/ohmyrepl.html">Creating a sysimage with OhMyREPL</a></li><li><a class="tocitem" href="../examples/plots.html">Creating a sysimage for fast plotting with Plots.jl</a></li></ul></li><li><a class="tocitem" href="../refs.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="sysimages_part_1.html">Creating a sysimage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="sysimages_part_1.html">Creating a sysimage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/PackageCompiler.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/PackageCompiler.jl/blob/master/docs/src/devdocs/sysimages_part_1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-tutorial-sysimage"><a class="docs-heading-anchor" href="#man-tutorial-sysimage">Creating a sysimage</a><a id="man-tutorial-sysimage-1"></a><a class="docs-heading-anchor-permalink" href="#man-tutorial-sysimage" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This section is for people who want to understand PackageCompiler.jl under the hood. It is not required reading to use the package.</p></div></div><h2 id="Julia&#39;s-compilation-model-and-sysimages"><a class="docs-heading-anchor" href="#Julia&#39;s-compilation-model-and-sysimages">Julia&#39;s compilation model and sysimages</a><a id="Julia&#39;s-compilation-model-and-sysimages-1"></a><a class="docs-heading-anchor-permalink" href="#Julia&#39;s-compilation-model-and-sysimages" title="Permalink"></a></h2><p>Julia is a JIT-compiled language. More specifically, functions are compiled just before getting executed. A more suitable description of the Julia compilation model might, therefore, be Just-Ahead-of-Time (JAOT) compilation. The term JIT is sometimes used to describe the compilation model where code is dynamically recompiled based on runtime performance data, which Julia does not do. At the same time, Julia comes with a lot of built-in functionality including several standard libraries. If all this built-in functionality would need to be parsed, type inferred and compiled every time Julia started, the startup-time would be longer than reasonable. Therefore, Julia bundles something called a &quot;sysimage&quot; which is a <a href="https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries">shared library</a> where (roughly) the state of a running Julia session has been stored (serialized).  When Julia starts, this sysimage gets loaded, which is a quite quick process (50ms on the author&#39;s machine), and all the cached compiled code can immediately be used, without requiring any compilation.</p><h2 id="Custom-sysimages"><a class="docs-heading-anchor" href="#Custom-sysimages">Custom sysimages</a><a id="Custom-sysimages-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-sysimages" title="Permalink"></a></h2><p>There are cases where one wants to generate a custom sysimage for a similar reason as to why Julia bundles one: to reduce time from Julia start until the program is executing. The time from startup to execution is here denoted as &quot;latency&quot; and we want to minimize the latency of our program.  A drawback of putting a package inside the sysimage is that it becomes &quot;frozen&quot; at the particular version it was, when it got put into the sysimage. In addition, all the dependencies of the package put into the sysimage will be frozen in the same manner.  In particular, it will no longer be updated like normal packages when using the package manager. In some cases, other ways of reducing latency might be preferable, for example, using <a href="https://github.com/timholy/Revise.jl">Revise.jl</a></p><h2 id="Example-workload"><a class="docs-heading-anchor" href="#Example-workload">Example workload</a><a id="Example-workload-1"></a><a class="docs-heading-anchor-permalink" href="#Example-workload" title="Permalink"></a></h2><p>To have something concrete to work with, let&#39;s assume we have a small script that reads a CSV-file and computes some statistics on it.  As an example, we will use a sample CSV file containing Florida insurance data, which can be downloaded <a href="http://spatialkeydocs.s3.amazonaws.com/FL_insurance_sample.csv.zip">from here</a>.</p><p>One way of loading this file into Julia is by using the <code>CSV.jl</code> package. We can install <code>CSV.jl</code> using the Julia package manager <code>Pkg</code> as:</p><pre><code class="language-julia-repl hljs">julia&gt; import Pkg; Pkg.add(&quot;CSV&quot;)
 Resolving package versions...
  Updating `~/.julia/environments/v1.3/Project.toml`
  [336ed68f] + CSV v0.5.13
  Updating `~/.julia/environments/v1.3/Manifest.toml`
 [no changes]</code></pre><p>When a package is loaded for the first time it gets &quot;precompiled&quot;:</p><pre><code class="language-julia-repl hljs">julia&gt; @time using CSV
[ Info: Precompiling CSV [336ed68f-0bac-5ca0-87d4-7b16caf5d00b]
 13.321758 seconds (2.69 M allocations: 151.302 MiB, 0.05% gc time)</code></pre><p>The term &quot;precompiled&quot; can be a bit misleading since there is no native compiled code cached in the precompilation file. Julia is dynamically typed so it is not obvious what types to compile the different methods for.</p><p>Even with <code>CSV</code> &quot;precompiled&quot;, there is a still some loading time, but it is significantly lower:</p><pre><code class="language-julia-repl hljs">julia&gt; @time using CSV
  0.694224 seconds (1.90 M allocations: 114.210 MiB)</code></pre><p>Let&#39;s load the sample CSV file:</p><pre><code class="language-julia-repl hljs">julia&gt; @time CSV.read(&quot;FL_insurance_sample.csv&quot;);
9.264898 seconds (37.17 M allocations: 2.278 GiB, 3.90% gc time)1</code></pre><p>That&#39;s is quite a long time to read a smallish CSV file. One way to check the compilation overhead is by running the function again:</p><pre><code class="language-julia-repl hljs">julia&gt; @time CSV.read(&quot;FL_insurance_sample.csv&quot;);
  0.083543 seconds (423 allocations: 34.695 KiB)</code></pre><p>So clearly, the first call to the function is dominated by compilation time. In many cases, this is not a problem in practice since often one wants to parse multiple CSV files such that the overhead will become negligible or one keeps a Julia session open for a longer time so that the compiled version of the function is still in memory.</p><p>However, since the end goal of this blog series is to create an executable that can be distributed we want to try to avoid as much runtime compilation (latency) as possible.</p><h2 id="Creating-a-custom-sysimage"><a class="docs-heading-anchor" href="#Creating-a-custom-sysimage">Creating a custom sysimage</a><a id="Creating-a-custom-sysimage-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-custom-sysimage" title="Permalink"></a></h2><p>If we time the loading of a standard library, it is clear that it is &quot;cached&quot; somehow since the time to load it is so short:</p><pre><code class="language-julia-repl hljs">julia&gt; @time using Dates
  0.000816 seconds (1.25 k allocations: 65.625 KiB)</code></pre><p>Since <code>Dates</code> is a standard library it comes bundled in the system image.  In fact, <code>Dates</code> is already &quot;loaded&quot; when starting Julia. The effect of running <code>using Dates</code> just makes the module available in the <code>Main</code> module namespace which is what the REPL evaluates in.</p><p>Delving into some internals, there is a dictionary in <code>Base</code> that keeps track of all loaded modules:</p><pre><code class="language-julia-repl hljs">julia&gt; Base.loaded_modules
Dict{Base.PkgId,Module} with 33 entries:
  SHA [ea8e919c-243c-51af-8825-aaa63cd721ce]              =&gt; SHA
  Profile [9abbd945-dff8-562f-b5e8-e1ebf5ef1b79]          =&gt; Profile
  Dates [ade2ca70-3891-5945-98fb-dc099432e06a]            =&gt; Dates
  Mmap [a63ad114-7e13-5084-954f-fe012c677804]             =&gt; Mmap
...</code></pre><p>and we can here see the <code>Dates</code> module is there, even after restarting Julia. This means that <code>Dates</code> is in the sysimage itself and does not have to be loaded from anywhere external.</p><p>Creating and using a custom sysimage is done in three steps:</p><ol><li>Start Julia with the <code>--output-o=sys.o custom_sysimage.jl</code> where <code>custom_sysimage.jl</code> is a file that creates the state that we want the sysimage to contain and <code>sys.o</code> is the resulting <a href="https://en.wikipedia.org/wiki/Object_file">object file</a> that we will turn into a sysimage.</li><li>Create a shared library from the object file by linking it with <code>libjulia</code>. This is the actual sysimage.</li><li>Use the custom sysimage in Julia with the <code>-Jpath/to/sysimage</code> (or the longer, more descriptive <code>--sysimage</code>) flag.</li></ol><h3 id="1.-Creating-the-object-file"><a class="docs-heading-anchor" href="#1.-Creating-the-object-file">1. Creating the object file</a><a id="1.-Creating-the-object-file-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Creating-the-object-file" title="Permalink"></a></h3><p>For now, the goal is to put <code>CSV</code> in the sysimage (in the same way as the standard library <code>Dates</code> is in it). We therefore initially simply create a file called <code>custom_sysimage.jl</code> with the content.</p><pre><code class="language-julia hljs">using CSV</code></pre><p>in a <code>custom_sysimage.jl</code> file. Let&#39;s try using the flag <code>--output-o</code> (and disabling using the startup file) and running the file:</p><pre><code class="nohighlight hljs">julia --startup-file=no --output-o=sys.o -- custom_sysimage.jl
ERROR: could not open file boot.jl</code></pre><p>That did not work well. It turns out that when using the <code>--output-o</code> option one has to explicitly give a sysimage path (<a href="https://github.com/JuliaLang/julia/blob/49fb7924498e9fe813444cc684a24002e75b2ac9/src/jloptions.c#L533">due to this line</a>).  Since we do not have a custom sysimage yet we just want to give the path to the default sysimage which we can get the path to via:</p><pre><code class="language-julia-repl hljs">julia&gt; unsafe_string(Base.JLOptions().image_file)
&quot;/home/kc/julia/lib/julia/sys.so&quot;</code></pre><p>Let&#39;s try again, specifying the default sysimage path with the <code>-J</code> flag:</p><pre><code class="nohighlight hljs">julia --startup-file=no --output-o sys.o -J&quot;/home/kc/julia/lib/julia/sys.so&quot; custom_sysimage.jl
signal (11): Segmentation fault
in expression starting at none:0
uv_write2 at /workspace/srcdir/libuv/src/unix/stream.c:1397
uv_write at /workspace/srcdir/libuv/src/unix/stream.c:1492
jl_uv_write at /buildworker/worker/package_linux64/build/src/jl_uv.c:476
uv_write_async at ./stream.jl:967
uv_write at ./stream.jl:924</code></pre><p>Failure again! Another caveat when using <code>--output-o</code> is that modules <code>__init__()</code> functions do not end up getting called, which is what normally happens when a module is loaded. The reason for this is that often the state that gets defined in <code>__init__</code> is not something that you want to serialize to a file. In this particular case, some parts of the IO system have not been initialized so Julia crashes while trying to print an error. The magic incantation to make IO work properly is <code>Base.reinit_stdio()</code>. To figure out the actual problem we modify the <code>custom_sysimage.jl</code> file to look like:</p><pre><code class="language-julia hljs">Base.reinit_stdio()
using CSV</code></pre><p>and rerun the julia-command:</p><pre><code class="nohighlight hljs">julia --startup-file=no --output-o sys.o -J&quot;/home/kc/julia/lib/julia/sys.so&quot; custom_sysimage.jl
ERROR: LoadError: ArgumentError: Package CSV not found in current path:
- Run `import Pkg; Pkg.add(&quot;CSV&quot;)` to install the CSV package.

Stacktrace:
 [1] require(::Module, ::Symbol) at ./loading.jl:887
 [2] include at ./boot.jl:328 [inlined]
 [3] include_relative(::Module, ::String) at ./loading.jl:1105
 [4] include(::Module, ::String) at ./Base.jl:31
 [5] exec_options(::Base.JLOptions) at ./client.jl:295
 [6] _start() at ./client.jl:468
in expression starting at /home/kc/custom_sysimage.jl:2</code></pre><p>Okay, now we can see the error. Julia can not find the <code>CSV</code> package.  Package-loading in Julia is based on the two arrays <code>LOAD_PATH</code> and <code>DEPOT_PATH</code>. Adding <code>@show LOAD_PATH</code> and <code>@show DEPOT_PATH</code> to the <code>custom_sysimage.jl</code> file and rerunning the command above prints:</p><pre><code class="language-julia hljs">LOAD_PATH = String[]
DEPOT_PATH = String[]</code></pre><p>Again, we have an initialization problem. Looking at <a href="https://github.com/JuliaLang/julia/blob/88c34fc51d962aaef973935942b2e073e2e2f398/base/sysimg.jl#L13-L14">what Julia itself does before including the standard libraries</a>, we can see that the functions initializing these variables are explicitly called. Let us do the same by updating the <code>custom_sysimage.jl</code> file to:</p><pre><code class="language-julia hljs">Base.init_depot_path()
Base.init_load_path()

using CSV

empty!(LOAD_PATH)
empty!(DEPOT_PATH)</code></pre><p>and running</p><pre><code class="nohighlight hljs">julia --startup-file=no --output-o sys.o -J&quot;/home/kc/julia/lib/julia/sys.so&quot; custom_sysimage.jl</code></pre><p>This time, after some waiting (2 min on the authors quite beefy computer) we do end up with a <code>sys.o</code> file.</p><h3 id="2.-Creating-the-sysimage-shared-library-from-the-object-file"><a class="docs-heading-anchor" href="#2.-Creating-the-sysimage-shared-library-from-the-object-file">2. Creating the sysimage shared library from the object file</a><a id="2.-Creating-the-sysimage-shared-library-from-the-object-file-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Creating-the-sysimage-shared-library-from-the-object-file" title="Permalink"></a></h3><p>The goal in this part is to take the object file, link it with <code>libjulia</code> to finally produce a shared library which is our sysimage.  For this, we need to use a C-compiler e.g. <code>gcc</code>. We need to link with <code>libjulia</code> so we need to give the compiler the path to where the julia library resides which can be gotten by:</p><pre><code class="language-julia-repl hljs">julia&gt; abspath(Sys.BINDIR, Base.LIBDIR)
&quot;/home/kc/julia/lib&quot;</code></pre><p>We tell <code>gcc</code> that we want a shared library with the <code>-shared</code> flag and to keep all symbols into the library by passing the <code>--whole-archive</code> to the linker (this is on Linux, see the later section for platform differences).  The final <code>gcc</code> invocation ends up as:</p><pre><code class="nohighlight hljs">gcc -shared -o sys.so -Wl,--whole-archive sys.o -Wl,--no-whole-archive -L&quot;/home/kc/julia/lib&quot; -ljulia</code></pre><p>which creates the sysimage <code>sys.so</code>.</p><p>We can compare the size of the new sysimage versus the default one and see that the new is a bit larger due to the extra packages it contains:</p><pre><code class="language-julia-repl hljs">julia&gt; stat(&quot;sys.so&quot;).size / (1024*1024)
162.16205596923828

julia&gt; stat(unsafe_string(Base.JLOptions().image_file)).size / (1024*1024)
147.0646743774414</code></pre><h4 id="Platform-differences"><a class="docs-heading-anchor" href="#Platform-differences">Platform differences</a><a id="Platform-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Platform-differences" title="Permalink"></a></h4><h5 id="macOS"><a class="docs-heading-anchor" href="#macOS">macOS</a><a id="macOS-1"></a><a class="docs-heading-anchor-permalink" href="#macOS" title="Permalink"></a></h5><p>On <code>macOS</code> the linker flag <code>-Wl,--whole-archive</code> is instead written as <code>-Wl,-all_load</code> so the command would be</p><pre><code class="nohighlight hljs">gcc -shared -o sys.dylib -Wl,-all_load sys.o -L&quot;/home/kc/Applications/julia-1.3.0-rc4/lib&quot; -ljulia</code></pre><p>Note that the extension has been changed from <code>so</code> to <code>dylib</code> which is the convention for shared libraries on macOS.</p><h5 id="Windows"><a class="docs-heading-anchor" href="#Windows">Windows</a><a id="Windows-1"></a><a class="docs-heading-anchor-permalink" href="#Windows" title="Permalink"></a></h5><p>Getting a compiler toolchain on Windows that works well with Julia is a bit trickier than on Linux or macOS.  One quite simple way is to follow the same process as needed to compile Julia on windows as outlined <a href="https://github.com/JuliaLang/julia/blob/master/doc/build/windows.md#cygwin-to-mingw-cross-compiling">here</a> and then use the <code>x86_64-w64-mingw32-gcc</code> compiler in Cygwin instead of <code>gcc</code>. Alternatively, a mingw compiler can be downloaded <a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/">from here</a> The <code>libjulia</code> is also in a different location on Windows. Instead of the <code>lib</code> folder it is in the <code>bin</code> folder.  Other than that, the same flags as for Linux should work to produce the sysimage shared library.</p><h3 id="3.-Running-Julia-with-the-new-sysimage"><a class="docs-heading-anchor" href="#3.-Running-Julia-with-the-new-sysimage">3. Running Julia with the new sysimage</a><a id="3.-Running-Julia-with-the-new-sysimage-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Running-Julia-with-the-new-sysimage" title="Permalink"></a></h3><p>We start Julia with the <code>-Jsys.so</code> flag to load the new custom <code>sys.so</code> sysimage (or <code>sys.dylib</code>, <code>sys.dll</code> on macOS and Windows respectively) and indeed loading CSV is now very fast:</p><pre><code class="language-julia-repl hljs">julia&gt; @time using CSV
  0.000432 seconds (665 allocations: 32.656 KiB)</code></pre><p>In fact, restarting Julia and looking at <code>Base.loaded_modules</code> we can see that, just like the standard libraries, CSV and its dependencies are already loaded when Julia is started:</p><pre><code class="language-julia-repl hljs">julia&gt; Base.loaded_modules
Dict{Base.PkgId,Module} with 52 entries:
   Parsers [69de0a69-1ddd-5017-9359-2bf0b02dc9f0] =&gt; Parsers
...
   CSV [336ed68f-0bac-5ca0-87d4-7b16caf5d00b]     =&gt; CSV
...</code></pre><p>However, remember that a large part of the latency was not loading the package but to compile the functions used by CSV the first time. Let&#39;s try it with the custom sysimage:</p><pre><code class="language-julia-repl hljs">julia&gt; @time using CSV
  0.001487 seconds (711 allocations: 35.203 KiB)

julia&gt; @time CSV.read(&quot;FL_insurance_sample.csv&quot;);
  3.609626 seconds (16.34 M allocations: 795.619 MiB, 5.88% gc time)

julia&gt; @time CSV.read(&quot;FL_insurance_sample.csv&quot;);
  0.026917 seconds (423 allocations: 34.695 KiB)</code></pre><p>Reading the CSV file is significantly faster than before but still a lot slower than the second time.  As previously mentioned, the native code for the functions in CSV is not compiled just by loading the package.  This means that even though CSV is in the sysimage the functions in CSV still need to be compiled.  The reason why the first call is faster at all is likely that loading packages can invalidate other methods and they thus have to be recompiled. With CSV in the sysimage, these invalidations have already been resolved.</p><h2 id="Recording-precompile-statements"><a class="docs-heading-anchor" href="#Recording-precompile-statements">Recording precompile statements</a><a id="Recording-precompile-statements-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-precompile-statements" title="Permalink"></a></h2><p>We are now at the stage where we have CSV in the sysimage, but we still suffer some latency because of compilation. Note that Julia is a dynamically typed language, it is therefore not known statically what types will be used in functions. Therefore, in order to be able to compile code one needs to know what types functions should be compiled for. One way to do this is to run some representative workload and record what types functions end up getting called with. This is a little bit like <a href="https://en.wikipedia.org/wiki/Profile-guided_optimization">Profile Guide Optimization (PGO)</a> while it here being something more like Profile Guided Compilation..</p><p>There is indeed a way for Julia to record what functions are getting compiled. We can save these and then when building the sysimage tell Julia to compile and store the native code for these functions.</p><p>We create a file called <code>generate_csv_precompile.jl</code> containing some &quot;training code&quot; that we will use as a base to figure out what functions end up getting compiled:</p><pre><code class="language-julia hljs">using CSV
CSV.read(&quot;FL_insurance_sample.csv&quot;)</code></pre><p>We then make julia run this code but we add the  <code>--trace-compile</code> flag to output &quot;precompilation statements&quot; to a file:</p><pre><code class="nohighlight hljs">julia --startup-file=no --trace-compile=csv_precompile.jl generate_csv_precompile.jl</code></pre><p>Looking at <code>csv_precompile.jl</code> we can see hundreds of functions that end up getting compiled. For example, the line</p><pre><code class="language-julia hljs">precompile(Tuple{typeof(CSV.getsource), String, Bool})</code></pre><p>instructs julia to compile the function <code>CSV.getsource</code> for the arguments of type <code>String</code> and <code>Bool</code>.</p><p>Note that some of the symbols in the list of precompile statements have a bit of a weird syntax containing <code>Symbol(#...)</code>, e.g:</p><pre><code class="language-julia hljs">precompile(Tuple{typeof(Base.map), getfield(CSV, Symbol(&quot;##4#5&quot;)), Base.SubString{String}})</code></pre><p>These are symbols that were not explicitly named in the source code but that Julia automatically gave an internal name to refer to.  These symbols are not necessarily consistent between different Julia versions or even Julia built for different operating systems.  It is possible to make the precompile statements more portable by filtering out any symbols starting with <code>#</code> but that naturally leaves some latency on the table since these now have to be compiled during runtime.</p><p>The way we make Julia cache the compilation of the functions in the list is simply by executing the statement on each line when the sysimage is created. It , unfortunately, isn&#39;t as simple as just adding an <code>include(&quot;csv_precompile&quot;)</code> to our <code>custom_precompile.jl</code> file.  Firstly, all the modules used in the precompilation statements (like <code>DataFrames</code>) are not defined in the Main namespace. Secondly, due to <a href="https://github.com/JuliaLang/julia/issues/28808">some bugs in the way Julia export precompile statements</a> running a precompile statement can fail.  The solution to these issues is to load all modules in the sysimage by looping through <code>Base.loaded_modules</code> and to use a <code>try-catch</code> for each precompile statement.  In addition, we evaluate everything in an anonymous module to not pollute the <code>Main</code> module with a bunch of symbols.</p><p>The end result is a <code>custom_sysimage.jl</code> file looking like:</p><pre><code class="language-julia hljs">Base.init_depot_path()
Base.init_load_path()

using CSV

@eval Module() begin
    for (pkgid, mod) in Base.loaded_modules
        if !(pkgid.name in (&quot;Main&quot;, &quot;Core&quot;, &quot;Base&quot;))
            eval(@__MODULE__, :(const $(Symbol(mod)) = $mod))
        end
    end
    for statement in readlines(&quot;csv_precompile.jl&quot;)
        try
            Base.include_string(@__MODULE__, statement)
        catch
            # See julia issue #28808
            @info &quot;failed to compile statement: $statement&quot;
        end
    end
end # module

empty!(LOAD_PATH)
empty!(DEPOT_PATH)</code></pre><p>After repeating the process of creating the object file and using a compiler to create the shared library sysimage, we are in a position to time again:</p><pre><code class="language-julia hljs">julia&gt; @time using CSV
  0.000408 seconds (665 allocations: 32.656 KiB)

julia&gt; @time CSV.read(&quot;FL_insurance_sample.csv&quot;);
  0.031504 seconds (441 allocations: 37.383 KiB)

julia&gt; @time CSV.read(&quot;FL_insurance_sample.csv&quot;);
  0.021355 seconds (423 allocations: 34.695 KiB)</code></pre><p>And finally, our first time for parsing the CSV-file is close to the second time.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 27 November 2024 20:33">Wednesday 27 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
