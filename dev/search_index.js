var documenterSearchIndex = {"docs":
[{"location":"devdocs/sysimages_part_1/#man-tutorial-sysimage-1","page":"Creating a sysimage","title":"Creating a sysimage","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#Julia's-compilation-model-and-sysimages-1","page":"Creating a sysimage","title":"Julia's compilation model and sysimages","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Julia is a JIT-compiled language. More specifically, functions are compiled just before getting executed. A more suitable description of the Julia compilation model might, therefore, be Just-Ahead-of-Time (JAOT) compilation. The term JIT is sometimes used to describe the compilation model where code is dynamically recompiled based on runtime performance data, which Julia does not do. At the same time, Julia comes with a lot of built-in functionality including several standard libraries. If all this built-in functionality would need to be parsed, type inferred and compiled every time Julia started, the startup-time would be longer than reasonable. Therefore, Julia bundles something called a \"sysimage\" which is a shared library where (roughly) the state of a running Julia session has been stored (serialized).  When Julia starts, this sysimage gets loaded, which is a quite quick process (50ms on the author's machine), and all the cached compiled code can immediately be used, without requiring any compilation.","category":"page"},{"location":"devdocs/sysimages_part_1/#Custom-sysimages-1","page":"Creating a sysimage","title":"Custom sysimages","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"There are cases where one wants to generate a custom sysimage for a similar reason as to why Julia bundles one: to reduce time from Julia start until the program is executing. The time from startup to execution is here denoted as \"latency\" and we want to minimize the latency of our program.  A drawback of putting a package inside the sysimage is that it becomes \"frozen\" at the particular version it was, when it got put into the sysimage. In addition, all the dependencies of the package put into the sysimage will be frozen in the same manner.  In particular, it will no longer be updated like normal packages when using the package manager. In some cases, other ways of reducing latency might be preferable, for example, using Revise.jl","category":"page"},{"location":"devdocs/sysimages_part_1/#Example-workload-1","page":"Creating a sysimage","title":"Example workload","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"To have something concrete to work with, let's assume we have a small script that reads a CSV-file and computes some statistics on it.  As an example, we will use a sample CSV file containing Florida insurance data, which can be downloaded from here.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"One way of loading this file into Julia is by using the CSV.jl package. We can install CSV.jl using the Julia package manager Pkg as:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> import Pkg; Pkg.add(\"CSV\")\n Resolving package versions...\n  Updating `~/.julia/environments/v1.3/Project.toml`\n  [336ed68f] + CSV v0.5.13\n  Updating `~/.julia/environments/v1.3/Manifest.toml`\n [no changes]","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"When a package is loaded for the first time it gets \"precompiled\":","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time using CSV\n[ Info: Precompiling CSV [336ed68f-0bac-5ca0-87d4-7b16caf5d00b]\n 13.321758 seconds (2.69 M allocations: 151.302 MiB, 0.05% gc time)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"The term \"precompiled\" can be a bit misleading since there is no native compiled code cached in the precompilation file. Julia is dynamically typed so it is not obvious what types to compile the different methods for.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Even with CSV \"precompiled\", there is a still some loading time, but it is significantly lower:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time using CSV\n  0.694224 seconds (1.90 M allocations: 114.210 MiB)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Let's load the sample CSV file:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time CSV.read(\"FL_insurance_sample.csv\");\n9.264898 seconds (37.17 M allocations: 2.278 GiB, 3.90% gc time)1","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"That's is quite a long time to read a smallish CSV file. One way to check the compilation overhead is by running the function again:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time CSV.read(\"FL_insurance_sample.csv\");\n  0.083543 seconds (423 allocations: 34.695 KiB)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"So clearly, the first call to the function is dominated by compilation time. In many cases, this is not a problem in practice since often one wants to parse multiple CSV files such that the overhead will become negligible or one keeps a Julia session open for a longer time so that the compiled version of the function is still in memory.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"However, since the end goal of this blog series is to create an executable that can be distributed we want to try to avoid as much runtime compilation (latency) as possible.","category":"page"},{"location":"devdocs/sysimages_part_1/#Creating-a-custom-sysimage-1","page":"Creating a sysimage","title":"Creating a custom sysimage","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"If we time the loading of a standard library, it is clear that it is \"cached\" somehow since the time to load it is so short:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time using Dates\n  0.000816 seconds (1.25 k allocations: 65.625 KiB)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Since Dates is a standard library it comes bundled in the system image.  In fact, Dates is already \"loaded\" when starting Julia. The effect of running using Dates just makes the module available in the Main module namespace which is what the REPL evaluates in.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Delving into some internals, there is a dictionary in Base that keeps track of all loaded modules:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> Base.loaded_modules\nDict{Base.PkgId,Module} with 33 entries:\n  SHA [ea8e919c-243c-51af-8825-aaa63cd721ce]              => SHA\n  Profile [9abbd945-dff8-562f-b5e8-e1ebf5ef1b79]          => Profile\n  Dates [ade2ca70-3891-5945-98fb-dc099432e06a]            => Dates\n  Mmap [a63ad114-7e13-5084-954f-fe012c677804]             => Mmap\n...","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"and we can here see the Dates module is there, even after restarting Julia. This means that Dates is in the sysimage itself and does not have to be loaded from amywhere external.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Creating and using a custom sysimage is done in three steps:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Start Julia with the --output-o=sys.o custom_sysimage.jl where custom_sysimage.jl is a file that creates the state that we want the sysimage to contain and sys.o is the resulting object file that we will turn into a sysimage.\nCreate a shared library from the object file by linking it with libjulia. This is the actual sysimage.\nUse the custom sysimage in Julia with the -Jpath/to/sysimage (or the longer, more descriptive --sysimage) flag.","category":"page"},{"location":"devdocs/sysimages_part_1/#.-Creating-the-object-file-1","page":"Creating a sysimage","title":"1. Creating the object file","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"For now, the goal is to put CSV in the sysimage (in the same way as the standard library Dates is in it). We therefore initially simply create a file called custom_sysimage.jl with the content.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"using CSV","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"in a custom_sysimage.jl file. Let's try using the flag --output-o (and disabling using the startup file) and running the file:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia --startup-file=no --output-o=sys.o -- custom_sysimage.jl\nERROR: could not open file boot.jl","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"That did not work well. It turns out that when using the --output-o option one has to explicitly give a sysimage path (due to this line).  Since we do not have a custom sysimage yet we just want to give the path to the default sysimage which we can get the path to via:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> unsafe_string(Base.JLOptions().image_file)\n\"/home/kc/julia/lib/julia/sys.so\"","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Let's try again, specifying the default sysimage path with the -J flag:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia --startup-file=no --output-o sys.o -J\"/home/kc/julia/lib/julia/sys.so\" custom_sysimage.jl\nsignal (11): Segmentation fault\nin expression starting at none:0\nuv_write2 at /workspace/srcdir/libuv/src/unix/stream.c:1397\nuv_write at /workspace/srcdir/libuv/src/unix/stream.c:1492\njl_uv_write at /buildworker/worker/package_linux64/build/src/jl_uv.c:476\nuv_write_async at ./stream.jl:967\nuv_write at ./stream.jl:924","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Failure again! Another caveat when using --output-o is that modules __init__() functions do not end up getting called, which is what normally happens when a module is loaded. The reason for this is that often the state that gets defined in __init__ is not something that you want to serialize to a file. In this particular case, some parts of the IO system have not been initialized so Julia crashes while trying to print an error. The magic incantation to make IO work properly is Base.reinit_stdio(). To figure out the actual problem we modify the custom_sysimage.jl file to look like:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Base.reinit_stdio()\nusing CSV","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"and rerun the julia-command:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia --startup-file=no --output-o sys.o -J\"/home/kc/julia/lib/julia/sys.so\" custom_sysimage.jl\nERROR: LoadError: ArgumentError: Package CSV not found in current path:\n- Run `import Pkg; Pkg.add(\"CSV\")` to install the CSV package.\n\nStacktrace:\n [1] require(::Module, ::Symbol) at ./loading.jl:887\n [2] include at ./boot.jl:328 [inlined]\n [3] include_relative(::Module, ::String) at ./loading.jl:1105\n [4] include(::Module, ::String) at ./Base.jl:31\n [5] exec_options(::Base.JLOptions) at ./client.jl:295\n [6] _start() at ./client.jl:468\nin expression starting at /home/kc/custom_sysimage.jl:2","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Okay, now we can see the error. Julia can not find the CSV package.  Package-loading in Julia is based on the two arrays LOAD_PATH and DEPOT_PATH. Adding @show LOAD_PATH and @show DEPOT_PATH to the custom_sysimage.jl file and rerunning the command above prints:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"LOAD_PATH = String[]\nDEPOT_PATH = String[]","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Again, we have an initialization problem. Looking at what Julia itself does before including the standard libraries, we can see that the functions initializing these variables are explicitly called. Let us do the same by updating the custom_sysimage.jl file to:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Base.init_depot_path()\nBase.init_load_path()\n\nusing CSV\n\nempty!(LOAD_PATH)\nempty!(DEPOT_PATH)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"and running","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia --startup-file=no --output-o sys.o -J\"/home/kc/julia/lib/julia/sys.so\" custom_sysimage.jl","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"This time, after some waiting (2 min on the authors quite beefy computer) we do end up with a sys.o file.","category":"page"},{"location":"devdocs/sysimages_part_1/#.-Creating-the-sysimage-shared-library-from-the-object-file-1","page":"Creating a sysimage","title":"2. Creating the sysimage shared library from the object file","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"The goal in this part is to take the object file, link it with libjulia to finally produce a shared library which is our sysimage.  For this, we need to use a C-compiler e.g. gcc. We need to link with libjulia so we need to give the compiler the path to where the julia library resides which can be gotten by:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> abspath(Sys.BINDIR, Base.LIBDIR)\n\"/home/kc/julia/lib\"","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"We tell gcc that we want a shared library with the -shared flag and to keep all symbols into the library by passing the --whole-archive to the linker (this is on Linux, see the later section for platform differences).  The final gcc invocation ends up as:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"gcc -shared -o sys.so -Wl,--whole-archive sys.o -Wl,--no-whole-archive -L\"/home/kc/julia/lib\" -ljulia","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"which creates the sysimage sys.so.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"We can compare the size of the new sysimage versus the default one and see that the new is a bit larger due to the extra packages it contains:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> stat(\"sys.so\").size / (1024*1024)\n162.16205596923828\n\njulia> stat(unsafe_string(Base.JLOptions().image_file)).size / (1024*1024)\n147.0646743774414","category":"page"},{"location":"devdocs/sysimages_part_1/#Platform-differences-1","page":"Creating a sysimage","title":"Platform differences","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#macOS-1","page":"Creating a sysimage","title":"macOS","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"On macOS the linker flag -Wl,--whole-archive is instead written as -Wl,-all_load so the command would be","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"gcc -shared -o sys.dylib -Wl,-all_load sys.o -L\"/home/kc/Applications/julia-1.3.0-rc4/lib\" -ljulia","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Note that the extension has been changed from so to dylib which is the convention for shared libraries on macOS.","category":"page"},{"location":"devdocs/sysimages_part_1/#Windows-1","page":"Creating a sysimage","title":"Windows","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Getting a compiler toolchain on Windows that works well with Julia is a bit trickier than on Linux or macOS.  One quite simple way is to follow the same process as needed to compile Julia on windows as outlined here and then use the x86_64-w64-mingw32-gcc compiler in Cygwin instead of gcc. Alternatively, a mingw compiler can be downloaded from here The libjulia is also in a different location on Windows. Instead of the lib folder it is in the bin folder.  Other than that, the same flags as for Linux should work to produce the sysimage shared library.","category":"page"},{"location":"devdocs/sysimages_part_1/#.-Running-Julia-with-the-new-sysimage-1","page":"Creating a sysimage","title":"3. Running Julia with the new sysimage","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"We start Julia with the -Jsys.so flag to load the new custom sys.so sysimage (or sys.dylib, sys.dll on macOS and Windows respecitively) and indeed loading CSV is now very fast:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time using CSV\n  0.000432 seconds (665 allocations: 32.656 KiB)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"In fact, restarting Julia and looking at Base.loaded_modules we can see that, just like the standard libraries, CSV and its dependencies are already loaded when Julia is started:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> Base.loaded_modules\nDict{Base.PkgId,Module} with 52 entries:\n   Parsers [69de0a69-1ddd-5017-9359-2bf0b02dc9f0] => Parsers\n...\n   CSV [336ed68f-0bac-5ca0-87d4-7b16caf5d00b]     => CSV\n...","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"However, remember that a large part of the latency was not loading the package but to compile the functions used by CSV the first time. Let's try it with the custom sysimage:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time using CSV\n  0.001487 seconds (711 allocations: 35.203 KiB)\n\njulia> @time CSV.read(\"FL_insurance_sample.csv\");\n  3.609626 seconds (16.34 M allocations: 795.619 MiB, 5.88% gc time)\n\njulia> @time CSV.read(\"FL_insurance_sample.csv\");\n  0.026917 seconds (423 allocations: 34.695 KiB)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Reading the CSV file is significantly faster than before but still a lot slower than the second time.  As previously mentioned, the native code for the functions in CSV is not compiled just by loading the package.  This means that even though CSV is in the sysimage the functions in CSV still need to be compiled.  The reason why the first call is faster at all is likely that loading packages can invalidate other methods and they thus have to be recompiled. With CSV in the sysimage, these invalidations have already been resolved.","category":"page"},{"location":"devdocs/sysimages_part_1/#Recording-precompile-statements-1","page":"Creating a sysimage","title":"Recording precompile statements","text":"","category":"section"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"We are now at the stage where we have CSV in the sysimage, but we still suffer some latency because of compilation. Note that Julia is a dynamically typed language, it is therefore not known statically what types will be used in functions. Therefore, in order to be able to compile code one needs to know what types functions should be compiled for. One way to do this is to run some representative workload and record what types functions end up getting called with. This is a little bit like Profile Guide Optimization (PGO) while it here being something more like Profile Guided Compilation..","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"There is indeed a way for Julia to record what functions are getting compiled. We can save these and then when building the sysimage tell Julia to compile and store the native code for these functions.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"We create a file called generate_csv_precompile.jl containing some \"training code\" that we will use as a base to figure out what functions end up getting compiled:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"using CSV\nCSV.read(\"FL_insurance_sample.csv\")","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"We then make julia run this code but we add the  --trace-compile flag to output \"precompilation statements\" to a file:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia --startup-file=no --trace-compile=csv_precompile.jl generate_csv_precompile.jl","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Looking at csv_precompile.jl we can see hundreds of functions that end up getting compiled. For example, the line","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"precompile(Tuple{typeof(CSV.getsource), String, Bool})","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"instructs julia to compile the function CSV.getsource for the arguments of type String and Bool.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Note that some of the symbols in the list of precompile statements have a bit of a weird syntax containing Symbol(#...), e.g:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"precompile(Tuple{typeof(Base.map), getfield(CSV, Symbol(\"##4#5\")), Base.SubString{String}})","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"These are symbols that were not explicitly named in the source code but that Julia automatically gave an internal name to refer to.  These symbols are not necessarily consistent between different Julia versions or even Julia built for different operating systems.  It is possible to make the precompile statements more portable by filtering out any symbols starting with # but that naturally leaves some latency on the table since these now have to be compiled during runtime.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"The way we make Julia cache the compilation of the functions in the list is simply by executing the statement on each line when the sysimage is created. It , unfortunately, isn't as simple as just adding an include(\"csv_precompile\") to our custom_precompile.jl file.  Firstly, all the modules used in the precompilation statements (like DataFrames) are not defined in the Main namespace. Secondly, due to some bugs in the way Julia export precompile statements running a precompile statement can fail.  The solution to these issues is to load all modules in the sysimage by looping through Base.loaded_modules and to use a try-catch for each precompile statement.  In addition, we evaluate everything in an anonymous module to not pollute the Main module which a bunch of symbols.","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"The end result is a custom_sysimage.jl file looking like:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"Base.init_depot_path()\nBase.init_load_path()\n\nusing CSV\n\n@eval Module() begin\n    for (pkgid, mod) in Base.loaded_modules\n        if !(pkgid.name in (\"Main\", \"Core\", \"Base\"))\n            eval(@__MODULE__, :(const $(Symbol(mod)) = $mod))\n        end\n    end\n    for statement in readlines(\"csv_precompile.jl\")\n        try\n            Base.include_string(@__MODULE__, statement)\n        catch\n            # See julia issue #28808\n            @info \"failed to compile statement: $statement\"\n        end\n    end\nend # module\n\nempty!(LOAD_PATH)\nempty!(DEPOT_PATH)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"After repeating the process of creating the object file and using a compiler to create the shared library sysimage, we are in a position to time again:","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"julia> @time using CSV\n  0.000408 seconds (665 allocations: 32.656 KiB)\n\njulia> @time CSV.read(\"FL_insurance_sample.csv\");\n  0.031504 seconds (441 allocations: 37.383 KiB)\n\njulia> @time CSV.read(\"FL_insurance_sample.csv\");\n  0.021355 seconds (423 allocations: 34.695 KiB)","category":"page"},{"location":"devdocs/sysimages_part_1/#","page":"Creating a sysimage","title":"Creating a sysimage","text":"And finally, our first time for parsing the CSV-file is close to the second time.","category":"page"},{"location":"apps/#Apps-1","page":"Apps","title":"Apps","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"With an \"app\" we here mean a \"bundle\" of files where one of these files is an executable and where this bundle can be sent to another machine while still allowing the executable to run.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Use-cases for Julia-apps are for example when one wants to provide some kind of functionality where the fact that the code was written in Julia is just an implementation detail and where requiring the user to download and use Julia to run the code would be a distraction. There is also no need to provide the original Julia source code for apps since everything gets baked into the sysimage.","category":"page"},{"location":"apps/#Relocatability-1","page":"Apps","title":"Relocatability","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Since we want to send the app to other machines the app we create must be \"relocatable\".  With an app being relocatable we mean it does not rely on specifics of the machine where the app was created.  Relocatability is not an absolute measure, most apps assume some properties of the machine they will run on, like what operating system is installed and the presence of graphics drivers if one wants to show graphics. On the other hand, embedding things into the app that is most likely unique to the machine, such as absolute paths to libraries, means that the application almost surely will not run properly on another machine.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"For something to be relocatable, everything that it depends on must also be relocatable.  In the case of an app, the app itself and all the Julia packages it depends on must also relocatable. This is a bit of an issue because the Julia package ecosystem has rarely given much thought to relocatability since creating \"apps\" has not been common.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The main problem with relocatability of Julia packages is that many packages are encoding fundamentally non-relocatable information into the source code. As an example, many packages tend to use a build.jl file (which runs when the package is first installed) that looks something like:","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"lib_path = find_library(\"libfoo\")\nwrite(\"deps.jl\", \"const LIBFOO_PATH = $(repr(lib_path))\")","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The main package file then contains:","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"module Package\n\nif !isfile(\"../build/deps.jl\")\n    error(\"run Pkg.build(\\\"Package\\\") to re-build Package\")\nend\ninclude(\"../build/deps.jl\")\nfunction __init__()\n    libfoo = Libdl.dlopen(LIBFOO_PATH)\nend\n\n...\n\nend # module","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The absolute path to lib_path that find_library found is thus effectively included into the source code of the package. Arguably, the whole build system in Julia is inherently non-relocatable because it runs when the package is being installed which is a concept that does not make sense when distributing an app.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Some packages do need to call into external libraries and use external binaries so the question then arises: \"how are these packages supposed to do this in a relocatable way?\"  The answer is to use the \"artifact system\" introduced in Julia 1.3, and described in the following blog post. The artifact system is a declarative way of downloading and using \"external files\" like binaries and libraries.  How this is used in practice is described later.","category":"page"},{"location":"apps/#Creating-an-app-1","page":"Apps","title":"Creating an app","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The source of an app is a package with a project and manifest file. It should define a function with the signature","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"function julia_main()::Cint\n  # do something based on ARGS?\n  return 0 # if things finished successfully\nend","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"which will be the entry point of the app (the function that runs when the executable in the app is run). A skeleton of an app to start working from can be found here.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Regarding relocatability, PackageCompiler provides a function audit_app(app_dir::String) that tries to find common problems with relocatability in the app.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The app is then compiled using the create_app function that takes a path to the source code of the app and the destination where the app should be compiled to. This will bundle all required libraries for the app to run on another machine where the same Julia that created the app can run.  As an example, in the code snippet below, the example app linked above is compiled and run:","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"~/PackageCompiler.jl/examples\n❯ julia -q --project\n\njulia> using PackageCompiler\n\njulia> create_app(\"MyApp\", \"MyAppCompiled\")\n[ Info: PackageCompiler: creating base system image (incremental=false), this might take a while...\n[ Info: PackageCompiler: creating system image object file, this might take a while...\n\njulia> exit()\n\n~/PackageCompiler.jl/examples\n❯ MyAppCompiled/bin/MyApp\nARGS = [\"foo\", \"bar\"]\nBase.PROGRAM_FILE = \"MyAppCompiled/bin/MyApp\"\n...\nHello, World!\n\nRunning the artifact\nThe result of 2*5^2 - 10 == 40.000000\nunsafe_string((Base.JLOptions()).image_file) = \"/Users/kristoffer/PackageCompiler.jl/examples/MyAppCompiled/bin/MyApp.dylib\"\nExample.domath(5) = 10","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The resulting executable is found in the bin folder in the compiled app directory.  The compiled app directory MyAppCompiled could now be put into an archive and sent to another machine or an installer could be wrapped around the directory, perhaps providing a better user experience than just an archive of files.","category":"page"},{"location":"apps/#Precompilation-1","page":"Apps","title":"Precompilation","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"In the same way as files for precompilation could be given when creating sysimages, the same keyword arguments are used to add precompilation to apps.","category":"page"},{"location":"apps/#Incremental-vs-non-incremental-sysimage-1","page":"Apps","title":"Incremental vs non-incremental sysimage","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"In the section about creating sysimages, there was a short discussion about incremental vs non-incremental sysimages. In short, an incremental sysimage is built on top of another sysimage, while a non-incremental is created from scratch. For sysimages, it makes sense to use an incremental sysimage built on top of Julia's default sysimage since we wanted the benefit of having a responsive REPL that it provides.  For apps, this is no longer the case, the sysimage is not meant to be used when working interactively, it only needs to be specialized for the specific app.  Therefore, by default, incremental=false is used for create_app. If, for some reason, one wants an incremental sysimage, incremental=true could be passed to create_app.  With the example app, a non-incremental sysimage is about 70MB smaller than the default sysimage.","category":"page"},{"location":"apps/#Filtering-stdlibs-1","page":"Apps","title":"Filtering stdlibs","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"By default, all standard libraries are included in the sysimage.  It is possible to only include those standard libraries that the project needs.  This is done by passing the keyword argument filter_stdlibs=true to create_app. This causes the sysimage to be smaller, and possibly load faster.  The reason this is not the default is that it is possible to \"accidentally\" depend on a standard library without it being reflected in the Project file.  For example, it is possible to call rand() from a package without depending on Random, even though that is where the method is defined. If Random was excluded from the sysimage that call would then error. The same thing is true for e.g. matrix multiplication, rand(3,3) * rand(3,3) requires both the standard libraries LinearAlgebra and Random This is because these standard libraries do \"type-piracy\" so just loading those packages can cause code to change behavior.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Nevertheless, the option is there to use. Just make sure to properly test the app with the resulting sysimage.","category":"page"},{"location":"apps/#Custom-binary-name-1","page":"Apps","title":"Custom binary name","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"By default, the binary in the bin directory take the name of the project, as defined in Project.toml.  If you want to change the name, you can pass app_name=\"some_app_name\" to create_app.","category":"page"},{"location":"apps/#Artifacts-1","page":"Apps","title":"Artifacts","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The way to depend on external libraries or binaries when creating apps is by using the artifact system. PackageCompiler will bundle all artifacts needed by the project, and set up things so that they can be found during runtime on other machines.","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"The example app uses the artifact system to depend on a very simple toy binary that does some simple arithmetic. It is instructive to see how the artifact file is used in the source.","category":"page"},{"location":"apps/#Reverse-engineering-the-compiled-app-1","page":"Apps","title":"Reverse engineering the compiled app","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"While the created app is relocatable and no source code is bundled with it, there are still some things about the build machine and the source code that can be \"reverse engineered\".","category":"page"},{"location":"apps/#Absolute-paths-of-build-machine-1","page":"Apps","title":"Absolute paths of build machine","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Julia records the paths and line-numbers for methods when they are getting compiled.  These get cached into the sysimage and can be found e.g. by dumping all strings in the sysimage:","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"~/PackageCompiler.jl/examples/MyAppCompiled/bin\n❯ strings MyApp.so | grep MyApp\nMyApp\n/home/kc/PackageCompiler.jl/examples/MyApp/\nMyApp\n/home/kc/PackageCompiler.jl/examples/MyApp/src/MyApp.jl\n/home/kc/PackageCompiler.jl/examples/MyApp/src\nMyApp.jl\n/home/kc/PackageCompiler.jl/examples/MyApp/src/MyApp.jl","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"This is a problem that the Julia standard libraries themselves have:","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"julia> @which rand()\nrand() in Random at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Random/src/Random.jl:256","category":"page"},{"location":"apps/#Using-reflection-and-finding-lowered-code-1","page":"Apps","title":"Using reflection and finding lowered code","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"There is nothing preventing someone from starting Julia with the sysimage that comes with the app.  And while the source code is not available one can read the \"lowered code\" and use reflection to find things like the name of fields in structs and global variables etc:","category":"page"},{"location":"apps/#","page":"Apps","title":"Apps","text":"~/PackageCompiler.jl/examples/MyAppCompiled/bin kc/docs_apps*\n❯ julia -q -JMyApp.so\njulia> MyApp = Base.loaded_modules[Base.PkgId(Base.UUID(\"f943f3d7-887a-4ed5-b0c0-a1d6899aa8f5\"), \"MyApp\")]\nMyApp\n\njulia> names(MyApp; all=true)\n10-element Array{Symbol,1}:\n Symbol(\"#eval\")\n Symbol(\"#include\")\n Symbol(\"#julia_main\")\n Symbol(\"#real_main\")\n :MyApp\n :eval\n :include\n :julia_main\n :real_main\n :socrates\n\njulia> @code_lowered MyApp.real_main()\nCodeInfo(\n1 ─ %1  = MyApp.ARGS\n│         value@_2 = %1\n│   %3  = Base.repr(%1)\n│         Base.println(\"ARGS = \", %3)\n│         value@_2\n│   %6  = Base.PROGRAM_FILE\n│         value@_3 = %6\n│   %8  = Base.repr(%6)\n│         Base.println(\"Base.PROGRAM_FILE = \", %8)\n│         value@_3\n│   %11 = MyApp.DEPOT_PATH","category":"page"},{"location":"devdocs/relocatable_part_3/#man-tutorial-reloc-1","page":"Relocatable apps","title":"Relocatable apps","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"In the previous tutorials, we created a custom sysimage and a binary (app) that did some simple CSV parsing with an (depending on the exact demands) acceptable latency (time until the app starts doing real work).  However, trying to send this executable to another machine will fail spectacularly. This tutorial outlines how to create and package a bundle of files into an app that we can send to other machines and have them run, without for example, requiring Julia itself to be installed, and without having to ship the source code of the app.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The tutorial will not deal with any kind of file size optimization or \"tree shaking\" as it is sometimes called.","category":"page"},{"location":"devdocs/relocatable_part_3/#Why-is-the-built-executable-in-the-previous-tutorial-non-relocatable?-1","page":"Relocatable apps","title":"Why is the built executable in the previous tutorial non-relocatable?","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"With relocatability, we mean the ability of being able to send e.g. an executable (or a bundle of files including an executable, here called an app) to another machine and have it run there without too many assumptions of the state of the other machine. Relocatability is not an absolute measure, most apps assume some properties of the machine they will run on (like graphics drivers if one want to show graphics) but other (implicit) assumptions, like embedding absolute paths into source code would make the app almost completely non-relocatable since that absolute path is unlikely to exist on another machine.  The goal here is to make our app relocatable enough such that if we could install and run the same Julia as we use to build the app on the other machine, then the app should also run on that machine (with exceptions if some of our dependencies impose extra requirements on the machine).","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"So what is causing our executable that we built in the previous tutorial to not be relocatable? Firstly, our sysimage relies on libjulia which we currently load from the Julia directory and, in addition, libjulia itself relies on other libraries (like LLVM) to work. And secondly, the packages we embedded in the sysimage might have encoded assumptions about the current system into their code.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The first problem is quite easy to fix while the second one is harder since some popular packages that we might want to use as dependencies are inherently non-relocatable.  There is nothing to do about that except try to fix these packages.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"For now, we will ignore the problem of packages not being relocatable by only using a small dependency that we know does not have a relocatability problem. Later in the blog post, we will revisit this and discuss more in-depth what makes a package non-relocatable and how to fix this, even if the package needs things like external libraries or binaries (spoiler alert: it is using the artifact system presented in the blog about artifacts.","category":"page"},{"location":"devdocs/relocatable_part_3/#A-toy-app-1","page":"Relocatable apps","title":"A toy app","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The package we used in the previous examples to create a sysimage and executable was CSV.jl. Now, to simplify things, we will only use a very simple package with no relocatability problems that also has no dependencies. The app will take some input on stdin and print it out with color to the terminal using the Crayons.jl package.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"When we add the Crayons.jl package we use a separate project to encapsulate things better by creating a new project in the app directory:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ julia -q --project=.\n\njulia> using Pkg; Pkg.add(\"Crayons\")\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `~/MyApp/Project.toml`\n  [a8cc5b0e] + Crayons v4.0.1\n  Updating `~/MyApp/Manifest.toml`\n  [a8cc5b0e] + Crayons v4.0.1","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The code for the app itself is quite simple:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"module MyApp\nusing Crayons\n\nBase.@ccallable function julia_main()::Cint\n    try\n        real_main()\n    catch\n        Base.invokelatest(Base.display_error, Base.catch_stack())\n        return 1\n    end\n    return 0\nend\n\nfunction real_main()\n    Crayons.FORCE_COLOR[] = true\n    color = :red\n    for arg in ARGS\n        if !(arg in [\"red\", \"green\", \"blue\"])\n            error(\"invalid color $arg\")\n        end\n        color = Symbol(arg)\n    end\n    c = Crayon(foreground=color)\n    r = Crayon(reset=true)\n    while !eof(stdin)\n        txt = String(readavailable(stdin))\n        print(r, c, txt, r)\n    end\n    return 0\nend\nif abspath(PROGRAM_FILE) == @__FILE__\n    real_main()\nend\nend # module","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"It got the same high-level structure as the previous app in the earlier parts. The exact details are not so interesting but here a color is set based on the command-line arguments and the stdin is written to stdout with that color. We can see some usage of it:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"(Image: )","category":"page"},{"location":"devdocs/relocatable_part_3/#Precompilation-and-sysimage-1","page":"Relocatable apps","title":"Precompilation and sysimage","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"As in part 1 we generate precompilation statements and create a system image. When recording precompilation statements and creating the sysimage, we make sure to use the --project flag to use the packages declared in the local project:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ echo \"Hello, this is some stdin\" | julia --project --startup-file=no --trace-compile=app_precompile.jl MyApp.jl green","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The .o file is then created with the same generate_sysimage.jl file as in part 2:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ gcc -shared -o sys.so -Wl,--whole-archive sys.o -Wl,--no-whole-archive -L\"/home/kc/julia/lib\" -ljulia","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"And then the sysimage is linked:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ gcc -shared -o sys.so -Wl,--whole-archive sys.o -Wl,--no-whole-archive -L\"/home/kc/julia/lib\" -ljulia","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"Before moving on and creating the executable, we need to think about what other files we need for the app and the file structure we want.","category":"page"},{"location":"devdocs/relocatable_part_3/#File-structure-for-our-app-bundle-1","page":"Relocatable apps","title":"File structure for our app bundle","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"We already mentioned that libjulia has some dependencies.  Using ldd, we can see the dependencies and where the dynamic linker would load them from:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/julia/lib\n❯ ldd libjulia.so\n        linux-vdso.so.1 (0x00007ffec63c3000)\n        libLLVM-6.0.so => /home/kc/julia/lib/./julia/libLLVM-6.0.so (0x00007f925ef13000)\n        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f925eeea000)\n        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f925eedf000)\n        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f925eebc000)\n        libstdc++.so.6 => /home/kc/julia/lib/./julia/libstdc++.so.6 (0x00007f925eb3e000)\n        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f925e9ef000)\n        libgcc_s.so.1 => /home/kc/julia/lib/./julia/libgcc_s.so.1 (0x00007f925e7d5000)\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f925e5e4000)\n        /lib64/ld-linux-x86-64.so.2 (0x00007f9262356000)","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"So some libraries would be loaded from the (libdl, librt) system itself, and some are bundled with Julia (libLLVM, libstdc++ etc) in the julia folder inside lib.  The reason the dynamic linker finds the libraries in the subfolder is due to the rpath which can be seen with objdump:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"❯ objdump -x libjulia.so |grep RPATH\n  RPATH                $ORIGIN/julia:$ORIGIN","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"However, these are not the only libraries Julia (and its standard libraries) need. Libraries can also be dynamically opened at runtime (with dlopen).  For now, we will just bring all the libraries in lib/julia along (excluding the sysimage since we will use our sysimage).","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The plan is that on macOS and Linux the files are structured as:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"├── bin\n│   └── MyApp [executable]\n│   └── sys.so\n└── lib\n    ├── julia\n    │   ├── libamd.so -> libamd.so.2.4.6\n    │   ├── libamd.so.2 -> libamd.so.2.4.6\n    │   ├── libamd.so.2.4.6\n    │   ├── libcamd.so -> libcamd.so.2.4.6\n   ... ...\n    │   └── libz.so.1.2.11\n    ├── libjulia.so -> libjulia.so.1.3\n    ├── libjulia.so.1 -> libjulia.so.1.3\n    └── libjulia.so.1.3","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"On Windows, we will just store everything in bin due to no convenient way of using RPATH.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"We create a new folder lib and copy the libraries into it (and remove the sysimage, since we will create cusom sysimage anyway):","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ mkdir lib\n\n~/MyApp\n❯ cp -r ~/julia/lib/ .\n\n~/MyApp\n❯ rm lib/julia/sys.so","category":"page"},{"location":"devdocs/relocatable_part_3/#Creating-the-binary-and-the-bundle-1","page":"Relocatable apps","title":"Creating the binary and the bundle","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"With some tweaks to the rpath entry so that the executable can find libjulia the executable is created in the same way as in the previous tutorial.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ gcc -DJULIAC_PROGRAM_LIBNAME=\\\"sys.so\\\" -o MyApp MyApp.c sys.so -O2 -I'/home/kc/julia/include/julia' -L'/home/kc/julia/lib' -fpie -Wl,-rpath,'$ORIGIN:$ORIGIN/../lib' -ljulia","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"We then finally move the executable and the sysimage to the bin folder:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ mkdir bin\n\n~/MyApp\n❯ mv MyApp sys.so bin/","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"(Image: )","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The final bundle of our relocatable app is then created by putting the bin and lib folders into an archive:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ mkdir MyApp\n\n~/MyApp\n❯ cp bin/ lib/ MyApp\n\n~/MyApp\n❯ tar czvf MyApp.tar.gz MyApp\nMyApp/\nMyApp/bin/\nMyApp/bin/MyApp\nMyApp/bin/sys.so\nMyApp/lib/\nMyApp/lib/julia/\n...","category":"page"},{"location":"devdocs/relocatable_part_3/#macOS-consideration-1","page":"Relocatable apps","title":"macOS consideration","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"On macOS we need to run install_name_tool to make it use the rpath entries which is done by executing:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"install_name_tool -change sys.so @rpath/sys.so MyApp`","category":"page"},{"location":"devdocs/relocatable_part_3/#Information-about-source-code-and-build-machine-state-stored-in-resulting-app-1","page":"Relocatable apps","title":"Information about source code and build machine state stored in resulting app","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"It should be noted that there is some state from the machine where the sysimage and binary is built that can be observed and the original source code.  Using the strings application we can see what strings are embedded in an executable or library.  Running it and grepping for some relevant substrings we can see that a bunch of absolute paths are stored inside the sysimage:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp/MyApp/lib/julia\n❯ strings sys.so | grep /home/kc\n/home/kc/.julia/packages/Crayons/P4fls/src/downcasts.jl\n/home/kc/.julia/packages/Crayons/P4fls/src/crayon.jl\n/home/kc/.julia/packages/Crayons/P4fls/src/crayon_stack.jl\n/home/kc/MyApp/MyApp.jl\n/home/kc/.julia/packages/Crayons/P4fls/src/Crayons.jl\n/home/kc/.julia/packages/Crayons/P4fls/src/crayon_wrapper.jl\n/home/kc/.julia/packages/Crayons/P4fls/src/test_prints.jl\n/home/kc/.julia/packages/Crayons/P4fls/src/macro.jl","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"In addition, when we print the stacktrace upon failure in the main function, we also leak absolute paths of the build machine:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"~/MyApp\n❯ MyApp/bin/MyApp purple\nERROR: invalid color purple\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] real_main() at /home/kc/MyApp/MyApp.jl:20\n [3] julia_main() at /home/kc/MyApp/MyApp.jl:6","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"This could be avoided by not printing stacktraces and perhaps even binary patching out the paths in the sysimage (not covered in this blog post).","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The lowered code can also be read by loading the sysimage and using e.g. @code_lowered on methods.","category":"page"},{"location":"devdocs/relocatable_part_3/#Relocatability-of-Julia-packages-1","page":"Relocatable apps","title":"Relocatability of Julia packages","text":"","category":"section"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The main problem with relocatability of Julia packages is that many packages are encoding fundamentally non-relocatable information into the source code. As an example, many packages tend to use a build.jl file (which runs when the package is installed) that looks something like:","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"lib_path = find_library(\"libfoo\")\nwrite(\"deps.jl\", \"const LIBFOO_PATH = $(repr(lib_path))\")","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The main package file then contains","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"if !isfile(\"../build/deps.jl\")\n    error(\"run Pkg.build(\\\"Package\\\") to re-build Package\")\nend\ninclude(\"../build/deps.jl\")\n\nfunction __init__()\n    libfoo = Libdl.dlopen(LIBFOO_PATH)\nend","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The problem here is that deps.jl contains an absolute path to the library and this gets encoded into the source code of the package. If we would store the package in the sysimage and try use it on another system, it would error when initialized since the LIBFOO_PATH variable is not valid on the other system. However, sometimes we need to bundle libraries and data files since the package uses them. Fortunately, there is a plan for that which can be seen in the blog post about artifacts.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The idea is that with the new artifact system a file (Artifacts.toml), a package can declaratively list external libraries and files that it needs.  In addition, the artifact system provides a way to find these files at runtime in a deterministic way. It is then possible to make sure that all artifacts needed for the package is bundled in the app and can also be found by the package during runtime.","category":"page"},{"location":"devdocs/relocatable_part_3/#","page":"Relocatable apps","title":"Relocatable apps","text":"The details are left out here since they become a bit technical but it should give some incentive to switch to the artifact system.","category":"page"},{"location":"examples/plots/#Creating-a-sysimage-for-fast-plotting-with-Plots.jl-1","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"","category":"section"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"A common complaint about Julia is that the \"time to first plot\" is a bit longer than desired. In this example, we will create a sysimage that is made to specifically improve this.","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"To get a reference, we measure the time it takes to create the first plot with the default sysimage:","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"julia> @time using Plots\n  5.284989 seconds (5.22 M allocations: 308.954 MiB, 1.41% gc time)\n\njulia> @time (p = plot(rand(5), rand(5)); display(p))\n 13.769197 seconds (18.42 M allocations: 909.963 MiB, 1.75% gc time)","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"This is approximately 19 seconds from start of Julia to the first plot.","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"We now create a precompilation file with exactly this workload in precompile_plots.jl:","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"using Plots\np = plot(rand(5), rand(5))\ndisplay(p)","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"The custom sysimage is then created as:","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"using PackageCompiler\ncreate_sysimage(:Plots, sysimage_path=\"sys_plots.so\", precompile_execution_file=\"precompile_plots.jl\")","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"If we now start Julia with the flag --sysimage sys_plots.so and re-time our previous commands:","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"julia> @time using Plots\n  0.000826 seconds (852 allocations: 42.125 KiB)\n\njulia> @time (p = plot(rand(5), rand(5)); display(p))\n  0.139642 seconds (468.42 k allocations: 12.176 MiB)","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"which is a sizeable speedup.","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"Note that since we have more stuff in our sysimage, Julia is slightly slower to start (0.04 seconds on this machine):","category":"page"},{"location":"examples/plots/#","page":"Creating a sysimage for fast plotting with Plots.jl","title":"Creating a sysimage for fast plotting with Plots.jl","text":"# Default sysimage\n➜ time julia  -e ''\n    0.13s user 0.08s system 88% cpu 0.232 total\n\n# Custom sysimage\n➜ time julia --sysimage sys_plots.so -e ''\n    0.17s user 0.10s system 94% cpu 0.284 total","category":"page"},{"location":"refs/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"refs/#","page":"References","title":"References","text":"PackageCompiler.create_sysimage\nPackageCompiler.restore_default_sysimage\nPackageCompiler.create_app\nPackageCompiler.audit_app","category":"page"},{"location":"refs/#PackageCompiler.create_sysimage","page":"References","title":"PackageCompiler.create_sysimage","text":"create_sysimage(packages::Union{Symbol, Vector{Symbol}}; kwargs...)\n\nCreate a system image that includes the package(s) in packages.  An attempt to automatically find a compiler will be done but can also be given explicitly by setting the environment variable JULIA_CC to a path to a compiler\n\nKeyword arguments:\n\nsysimage_path::Union{String,Nothing}: The path to where  the resulting sysimage should be saved. If set to nothing the keyword argument  replace_defalt needs to be set to true.\nproject::String: The project that should be active when the sysimage is created,  defaults to the current active project.\nprecompile_execution_file::Union{String, Vector{String}}: A file or list of  files that contain code which precompilation statements should be recorded from.\nprecompile_statements_file::Union{String, Vector{String}}: A file or list of  files that contains precompilation statements that should be included in the sysimage.\nincremental::Bool: If true, build the new sysimage on top of the sysimage  of the current process otherwise build a new sysimage from scratch. Defaults to true.\nfilter_stdlibs::Bool: If true, only include stdlibs that are in the project file.  Defaults to false, only set to true if you know the potential pitfalls.\nreplace_default::Bool: If true, replaces the default system image which is automatically  used when Julia starts. To replace with the one Julia ships with, use restore_default_sysimage()\n\nAdvanced keyword arguments\n\ncpu_target::String: The value to use for JULIA_CPU_TARGET when building the system image.\nscript::String: Path to a file that gets executed in the --output-o process.\n\n\n\n\n\n","category":"function"},{"location":"refs/#PackageCompiler.restore_default_sysimage","page":"References","title":"PackageCompiler.restore_default_sysimage","text":"restore_default_sysimage()\n\nRestores the default system image to the one that Julia shipped with. Useful after running create_sysimage with replace_default=true.\n\n\n\n\n\n","category":"function"},{"location":"refs/#PackageCompiler.create_app","page":"References","title":"PackageCompiler.create_app","text":"create_app(app_source::String, compiled_app::String; kwargs...)\n\nCompile an app with the source in app_source to the folder compiled_app. The folder app_source needs to contain a package where the package include a function with the signature\n\njulia_main()::Cint\n    # Perhaps do something based on ARGS\n    ...\nend\n\nThe executable will be placed in a folder called bin in compiled_app and when the executabl run the julia_main function is called.\n\nAn attempt to automatically find a compiler will be done but can also be given explicitly by setting the envirnment variable JULIA_CC to a path to a compiler.\n\nKeyword arguments:\n\napp_name::String: an alternative name for the compiled app.  If not provided,  the name of the package (as specified in Project.toml) is used.\nprecompile_execution_file::Union{String, Vector{String}}: A file or list of  files that contain code which precompilation statements should be recorded from.\nprecompile_statements_file::Union{String, Vector{String}}: A file or list of  files that contains precompilation statements that should be included in the sysimage  for the app.\nincremental::Bool: If true, build the new sysimage on top of the sysimage  of the current process otherwise build a new sysimage from scratch. Defaults to false.\nfilter_stdlibs::Bool: If true, only include stdlibs that are in the project file.  Defaults to false, only set to true if you know the potential pitfalls.\naudit::Bool: Warn about eventual relocatability problems with the app, defaults  to true.\nforce::Bool: Remove the folder compiled_app if it exists before creating the app.\n\nAdvanced keyword arguments\n\ncpu_target::String: The value to use for JULIA_CPU_TARGET when building the system image.\n\n\n\n\n\n","category":"function"},{"location":"refs/#PackageCompiler.audit_app","page":"References","title":"PackageCompiler.audit_app","text":"audit_app(app_dir::String)\n\nCheck for possible problems with regards to relocatability for the project at app_dir.\n\nwarning: Warning\nThis cannot guarantee that the project is free of relocatability problems, it can only detect some known bad cases and warn about those.\n\n\n\n\n\n","category":"function"},{"location":"sysimages/#Sysimages-1","page":"Sysimages","title":"Sysimages","text":"","category":"section"},{"location":"sysimages/#What-is-a-sysimage-1","page":"Sysimages","title":"What is a sysimage","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"A sysimage is a file which, in a loose sense, contains a Julia session serialized to a file.  A \"Julia session\" includes things like loaded packages, global variables, inferred and compiled code, etc.  By starting Julia with a sysimage, the stored Julia session is deserialized and loaded. The idea behind the sysimage is that this deserialization is faster than having to reload packages and recompile code from scratch.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Julia ships with a sysimage that is used by default when Julia is started. That sysimage contains the Julia compiler itself, the standard libraries and also compiled code that has been put there to reduce the time required to do common operations, like working in the REPL.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Sometimes it is desirable to create a custom sysimage with custom precompiled code. This is the case if one has some dependencies that take a significant time to load or where the compilation time for the first call is uncomfortably long. This section of the documentation is intended to document how to use PackageCompiler to create such sysimages.","category":"page"},{"location":"sysimages/#Drawbacks-to-custom-sysimages-1","page":"Sysimages","title":"Drawbacks to custom sysimages","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"It should be clearly stated that there are some drawbacks to using a custom sysimage, thereby sidestepping the standard Julia package precompilation system.  The biggest drawback is that packages that are compiled into a sysimage (including their dependencies!) are \"locked\" to the version they where at when the sysimage was created. This means that no matter what package version you have installed in your current project, the one in the sysimage will take precedence. This can lead to bugs where you start with a project that needs a specific version of a package, but you have another one compiled into the sysimage.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Putting packages in the sysimage is therefore only recommended if the load time of those packages is a significant problem and when these packages are not frequently updated. In addition, compiling \"workflow packages\" like Revise.jl and OhMyREPL.jl and using that as a default sysimage might make sense.","category":"page"},{"location":"sysimages/#Creating-a-sysimage-using-PackageCompiler-1","page":"Sysimages","title":"Creating a sysimage using PackageCompiler","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"PackageCompiler provides the function create_sysimage to create a sysimage.  It takes as the first argument a package or a list of packages that should be embedded in the resulting sysimage. By default, the given packages are loaded from the active project but a specific project can be specified by giving a path with the project keyword. The location of the resulting sysimage is given by the sysimage_path keyword.  After the sysimage is created, giving the command flag -Jpath/to/sysimage will start Julia with the given sysimage.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Below is an example of a new sysimage, from a separate project, being created with the package Example.jl in it. Using Base.loaded_modules it can be seen that the package is loaded without having to explicitly import it.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~\n❯mkdir NewSysImageEnv\n\n~\n❯ cd NewSysImageEnv\n\n~/NewSysImageEnv 29s\n❯ julia -q\n\njulia> using PackageCompiler\n[ Info: Precompiling PackageCompiler [dffaa6cc-da53-48e5-b007-4292dfcc27f1]\n\n(v1.3) pkg> activate .\nActivating new environment at `~/NewSysImageEnv/Project.toml`\n\n(NewSysImageEnv) pkg> add Example\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `~/NewSysImageEnv/Project.toml`\n  [7876af07] + Example v0.5.3\n  Updating `~/NewSysImageEnv/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\njulia> create_sysimage(:Example; sysimage_path=\"ExampleSysimage.so\")\n[ Info: PackageCompiler: creating system image object file, this might take a while...\n\njulia> exit()\n\n~/NewSysImageEnv\n❯ ls\nExampleSysimage.so  Manifest.toml  Project.toml\n\n~/NewSysImageEnv\n❯ julia -q -JExampleSysimage.so\n\njulia> Base.loaded_modules\nDict{Base.PkgId,Module} with 34 entries:\n...\n  Example [7876af07-990d-54b4-ab0e-23690620f79a]          => Example\n...","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Alternatively, instead of giving a path to where the new sysimage should appear, one can choose to replace the default sysimage. This is done by omitting the sysimage_path keyword and instead adding replace_default=true, for example:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"create_sysimage([:Debugger, :OhMyREPL]; replace_default=true)","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"If this is the first time create_sysimage is called with replace_default, a backup of the default sysimage is created. The default sysimage can then be restored with restore_default_sysimage().","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Note that sysimages are created \"incrementally\" in the sense that they add to the sysimage of the process running PackageCompiler. If the default sysimage has been replaced, the next create_sysimage call will create a new sysimage based on the replaced sysimage. It is possible to create a sysimage non-incrementally by passing the incremental=false keyword. This will create a new system image from scratch. However, it will lose the special precompilation that the Julia bundled sysimage provides which is what make the REPL and package manager not require compilation after a Julia restart.. It is therefore unlikely that incremental=false is of much use unless in special cases for sysimage creation (for apps it is a different story though).","category":"page"},{"location":"sysimages/#Precompilation-1","page":"Sysimages","title":"Precompilation","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"The step where we included Example.jl in the sysimage meant that loading Example is now pretty much instant (the package is already loaded when Julia starts). However, functions inside Example.jl still need to be compiled when executed for the first time.  One way we can see this is by using the --trace-compile=stderr flag which outputs a \"precompile statement\" every time Julia compiles a function.  Running the hello function inside Example.jl we can see that it needs to be compiled (it shows the function Example.hello was compiled for the input type String.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ julia -JExampleSysimage.so --trace-compile=stderr -e 'import Example; Example.hello(\"friend\")'\nprecompile(Tuple{typeof(Example.hello), String})","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"To remedy this, we can give a \"precompile script\" to create_sysimage which causes functions executed in that script to be baked into the sysimage. As an example, the script below simply calls the hello function in Example:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ cat precompile_example.jl\nusing Example\nExample.hello(\"friend\")","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"We now create a new system image called ExampleSysimagePrecompile.so, where the precompile_execution_file keyword argument has been given, pointing to the file just shown above:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ julia-q\n\njulia> using PackageCompiler\n\n(v1.3) pkg> activate .\nActivating environment at `~/NewSysImageEnv/Project.toml`\n\njulia> PackageCompiler.create_sysimage(:Example; sysimage_path=\"ExampleSysimagePrecompile.so\",\n                                         precompile_execution_file=\"precompile_example.jl\")\n[ Info: PackageCompiler: creating system image object file, this might take a while...\n\njulia> exit()","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Using the just created system image, we can see that the hello function no longer needs to get compiled:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ julia -JExampleSysimagePrecompile.so --trace-compile=stderr -e 'import Example; Example.hello(\"friend\")'\n\n~/NewSysImageEnv\n❯","category":"page"},{"location":"sysimages/#Using-a-manually-generated-list-of-precompile-statements-1","page":"Sysimages","title":"Using a manually generated list of precompile statements","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Starting Julia with --trace-compile=file.jl will emit precompilation statements to file.jl for the duration of the started Julia process.  This can be useful in cases where it is difficult to give a script that executes the code (like with interactive use). A file with a list of such precompile statements can be used when creating a sysimage by passing the keyword argument precompile_statements_file. See the OhMyREPL.jl example in the docs for more details on how to use --trace-compile with PackageCompiler.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"It is also possible to use SnoopCompile.jl to create files with precompilation statements.","category":"page"},{"location":"sysimages/#Using-a-package's-test-suite-to-generate-precompile-statements-1","page":"Sysimages","title":"Using a package's test suite to generate precompile statements","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"It is also possible to use a package's test suite to generate a list of precompile statements by including the content:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"import Example\ninclude(joinpath(pkgdir(Example), \"test\", \"runtests.jl\"))","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"in the precompile file. Note that you need to have any test dependencies installed in your current project.","category":"page"},{"location":"upgrade/#upgrade-1","page":"Upgrade notes","title":"Upgrade from pre 1.0 PackageCompiler","text":"","category":"section"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"PackageCompiler.jl got significantly changed for the 1.0 release. This page is intended to provide some guidance in transitioning from the previous PackageCompiler to PackageCompiler 1.0. PackageCompiler 1.0 has quite extensive documentation which, in addition to this page, contains useful information when upgrading.","category":"page"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"If you want to keep using the older version of PackageCompiler you can add an entry","category":"page"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"[compat]\nPackageCompiler = \"0.6\"","category":"page"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"to your project file.","category":"page"},{"location":"upgrade/#General-notes-1","page":"Upgrade notes","title":"General notes","text":"","category":"section"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"PackageCompiler.jl now requires Julia 1.3.1.\nThere is no command-line interface anymore","category":"page"},{"location":"upgrade/#Sysimages-1","page":"Upgrade notes","title":"Sysimages","text":"","category":"section"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"The function to create a sysimage is now called create_sysimage instead of compile_incremental.\nThe tests of packages are no longer automatically run to gather precompile statements. If you wish to keep using package tests you can see an example of that in the documentation for creating a sysimage.","category":"page"},{"location":"upgrade/#Executables-1","page":"Upgrade notes","title":"Executables","text":"","category":"section"},{"location":"upgrade/#","page":"Upgrade notes","title":"Upgrade notes","text":"The function to create an executable is now called create_app instead of build_executable.\nThe julia_main function for executables should no longer take any arguments (just access the global ARGS) and no longer need to be annotated with Base.@ccallable.\nThe code for an executable need to be structured as a package, that is, with a Project.toml file and a src/Package.jl file etc.\nSee https://github.com/JuliaLang/PackageCompiler.jl/tree/master/examples/MyApp for an example of the source code for an executable.","category":"page"},{"location":"devdocs/binaries_part_2/#man-tutorial-binary-1","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"This section targets how to build an executable based on the custom sysimage so that it can be run without having to explicitly start a Julia session.","category":"page"},{"location":"devdocs/binaries_part_2/#Interacting-with-Julia-through-libjulia.-1","page":"Creating a binary from Julia code","title":"Interacting with Julia through libjulia.","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"The way to interact with Julia without using the Julia executable itself is by calling into the Julia runtime library (libjulia) from a C program.  A quite detail set of docs for how this is done can be found at the embedding chapter in the Julia manual and it is recommended to read before reading on.  Since this is supposed to highlight the interals of PackageCompiler, will not use the conveniences shown in that section (e.g. the julia-config.jl script) but it is good to know they exist.","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"A rough outline of the steps we will take to create an executable are:","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"Create our Julia app with a Base.@ccallable entry-point which means the Julia function can be called directly from C.\nCreate a custom sysimage to reduce latency (this is pretty much just doing part 1) and to hold the C-callable function from the first step.\nWrite an embedding wrapper in C that loads our custom sysimage, does some initialization and calls the entry point in the script.","category":"page"},{"location":"devdocs/binaries_part_2/#A-toy-application-1","page":"Creating a binary from Julia code","title":"A toy application","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"To have something concrete to work with we will create a very simple application.  Keeping with the spirit of CSV parsing, we will create a small app that parses a list of CSV files given as arguments to the app and prints the size of the parsed result. The code for the app (MyApp.jl) is shown below:","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"module MyApp\n\nusing CSV\n\nBase.@ccallable function julia_main()::Cint\n    try\n        real_main()\n    catch\n        Base.invokelatest(Base.display_error, Base.catch_stack())\n        return 1\n    end\n    return 0\nend\n\nfunction real_main()\n    for file in ARGS\n        if !isfile(file)\n            error(\"could not find file $file\")\n        end\n        df = CSV.read(file)\n        println(file, \": \", size(df, 1), \"x\", size(df, 2))\n    end\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    real_main()\nend\n\nend # module","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"The function julia_main has been annotated with Base.@ccallable which means that a function with the unmangled name will appear in the sysimage. This function is just a small wrapper function that calls out to real_main which does the actual work.  All the code that is executed is put inside a try-catch block since the error will otherwise happen in the C-code where the backtrace is not very good","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"To facilitate testing, we check if the file was directly executed and in that case, run the main function.  We can test (and time) the script on the sample CSV file from the first tutorial","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"❯ time julia MyApp.jl FL_insurance_sample.csv\nFL_insurance_sample.csv: 36634x18\njulia MyApp.jl FL_insurance_sample.csv  12.51s user 0.38s system 104% cpu 12.385 total","category":"page"},{"location":"devdocs/binaries_part_2/#Create-the-sysimage-1","page":"Creating a binary from Julia code","title":"Create the sysimage","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"As in the previous tutorial, we do a \"sample run\" of our app to record what functions end up getting compiled.  Here, we simply run the app on the sample CSV file since that should give good \"coverage\":","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"julia --startup-file=no --trace-compile=app_precompile.jl MyApp.jl \"FL_insurance_sample.csv\"","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"The custom_sysimage.jl script look similar to before with the exception that we added an include of the app file inside the anonymous module where the precompiliation statements are evaluated in:","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"Base.init_depot_path()\nBase.init_load_path()\n\n@eval Module() begin\n    Base.include(@__MODULE__, \"MyApp.jl\")\n    for (pkgid, mod) in Base.loaded_modules\n        if !(pkgid.name in (\"Main\", \"Core\", \"Base\"))\n            eval(@__MODULE__, :(const $(Symbol(mod)) = $mod))\n        end\n    end\n    for statement in readlines(\"app_precompile.jl\")\n        try\n            Base.include_string(@__MODULE__, statement)\n        catch\n            # See julia issue #28808\n            Core.println(\"failed to compile statement: \", statement)\n        end\n    end\nend # module\n\nempty!(LOAD_PATH)\nempty!(DEPOT_PATH)","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"The sysimage is then created as before:","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"❯ julia --startup-file=no -J\"/home/kc/julia/lib/julia/sys.so\" --output-o sys.o custom_sysimage.jl\n\n❯ gcc -shared -o sys.so -fPIC -Wl,--whole-archive sys.o -Wl,--no-whole-archive -L\"/home/kc/julia/lib\" -ljulia","category":"page"},{"location":"devdocs/binaries_part_2/#Windows-specific-flags-1","page":"Creating a binary from Julia code","title":"Windows-specific flags","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"For Windows we need to tell the linker to export all symbols via the flag -Wl,--export-all-symbols. Otherwise, the linker will fail to find julia_main when we build the executable.","category":"page"},{"location":"devdocs/binaries_part_2/#Creating-the-executable-1","page":"Creating a binary from Julia code","title":"Creating the executable","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#Embedding-code-1","page":"Creating a binary from Julia code","title":"Embedding code","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"The embedding script is the \"driver\" of the app. It initializes the julia runtime, does some other initialization, calls into our julia_main and then does some cleanup when it returns.  We can borrow a lot for this embedding script from the embedding manual there are however some things we ne ed to set up \"manually\" that Julia usually does by itself when starting Julia.  This includes assigning the PROGRAM_FILE variable as well as updating Base.ARGS to contain the correct values. The script MyApp.c ends up looking like:","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"// Standard headers\n#include <string.h>\n#include <stdint.h>\n\n// Julia headers (for initialization and gc commands)\n#include \"uv.h\"\n#include \"julia.h\"\n\nJULIA_DEFINE_FAST_TLS()\n\n// Forward declare C prototype of the C entry point in our application\nint julia_main();\n\nint main(int argc, char *argv[])\n{\n    uv_setup_args(argc, argv);\n\n    // initialization\n    libsupport_init();\n\n    // JULIAC_PROGRAM_LIBNAME defined on command-line for compilation\n    jl_options.image_file = JULIAC_PROGRAM_LIBNAME;\n    julia_init(JL_IMAGE_JULIA_HOME);\n\n    // Initialize Core.ARGS with the full argv.\n    jl_set_ARGS(argc, argv);\n\n    // Set PROGRAM_FILE to argv[0].\n    jl_set_global(jl_base_module,\n        jl_symbol(\"PROGRAM_FILE\"), (jl_value_t*)jl_cstr_to_string(argv[0]));\n\n    // Set Base.ARGS to `String[ unsafe_string(argv[i]) for i = 1:argc ]`\n    jl_array_t *ARGS = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"ARGS\"));\n    jl_array_grow_end(ARGS, argc - 1);\n    for (int i = 1; i < argc; i++) {\n        jl_value_t *s = (jl_value_t*)jl_cstr_to_string(argv[i]);\n        jl_arrayset(ARGS, s, i - 1);\n    }\n\n    // call the work function, and get back a value\n    int ret = julia_main();\n\n    // Cleanup and gracefully exit\n    jl_atexit_hook(ret);\n    return ret;\n}","category":"page"},{"location":"devdocs/binaries_part_2/#Building-the-executable-1","page":"Creating a binary from Julia code","title":"Building the executable","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"We now have all the pieces needed to build the executable; a sysimage and a driver script. It is compiled as:","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"❯ gcc -DJULIAC_PROGRAM_LIBNAME=\\\"sys.so\\\" -o MyApp MyApp.c sys.so -O2 -fPIE \\\n    -I'/home/kc/julia/include/julia' \\\n    -L'/home/kc/julia/lib' \\\n    -ljulia \\\n    -Wl,-rpath,'/home/kc/julia/lib:$ORIGIN'","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"where we have added an rpath entry into the executable so that the julia library can be found at runtime as well as the sys.so library (ORIGIN means to look in the same folder as the binary for shared libraries).","category":"page"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"❯ time ./MyApp FL_insurance_sample.csv\nFL_insurance_sample.csv: 36634x18\n./MyApp FL_insurance_sample.csv  0.19s user 0.09s system 242% cpu 0.115 total\n\n❯ ./MyApp non_existing.csv\nERROR: could not find file non_existing.csv\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] real_main() at /home/kc/MyApp/MyApp.jl:21\n [3] julia_main() at /home/kc/MyApp/MyApp.jl:7","category":"page"},{"location":"devdocs/binaries_part_2/#macOS-considerations-1","page":"Creating a binary from Julia code","title":"macOS considerations","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"On macOS, instead of $ORIGIN for the rpath, use @executable_path.","category":"page"},{"location":"devdocs/binaries_part_2/#Windows-considerations-1","page":"Creating a binary from Julia code","title":"Windows considerations","text":"","category":"section"},{"location":"devdocs/binaries_part_2/#","page":"Creating a binary from Julia code","title":"Creating a binary from Julia code","text":"On Windows, it is recommended to increase the size of the stack from the default 1 MB to 8MB which can be done by passing the -Wl,--stack,8388608 flag.  Windows doesn't have (at least in an as simple way as Linux and macOS) the concept of rpath.  The goto solution is to either set the PATH environment variable to the Julia bin folder or alternatively copy paste all the libraries in the Julia bin folder so they sit next to the executable.","category":"page"},{"location":"examples/ohmyrepl/#manual-omr-1","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"","category":"section"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"OhMyREPL.jl is a package that enhances the REPL with, for example, syntax highlighting.  It does, however, come with a bit of a startup time increase, so compiling a new system image with OhMyREPL included is useful.  Importing the OhMyREPL package is not the only factor that contributes to the extra load time from using OhMyREPL. In addition, the time of compiling functions that OhMyREPL uses is also a factor. Therefore, we also want to do \"Profile Guided Compilation\" (PGC), where we record what functions gets compiled when using OhMyREPL, so they can be cached into the system image. OhMyREPL is a bit different from most other packages in that it is used interactive. Normally to do PGC with PackageCompiler we pass a script to to execute as the precompile_execution_file which is used to collect compilation data, but in this case, we will use Julia to manually collect this data.","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"First install OhMyREPL in the global environement using import Pkg; Pkg.add(\"OhMyREPL\").  Run using OhMyREPL and write something (like 1+1). It should be syntax highlighted, but you might have noticed that there was a bit of a delay before the characters appeared. This is the extra latency from using the package that we want to get rid off.","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"(Image: OhMyREPL installation)","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"The first goal is to have Julia emit the functions it compiles when running OhMyREPL.  To this end, start Julia with the --trace-compile=ohmyrepl_precompile.jl flag. This will start a standard Julia session but all functions that get compiled are output to the file ohmyrepl_precompile.jl. In the Julia session, load OhMyREPL, use the REPL a bit so that the functionality of OhMyREPL is exercised. Quit Julia and look into the file ohmyrepl_precompile.  It should be filled with lines like:","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"precompile(Tuple{typeof(OhMyREPL.Prompt.insert_keybindings), Any})\nprecompile(Tuple{typeof(OhMyREPL.__init__)})","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"These are functions that Julia compiled. We now just tell create_sysimage to use these precompile statements when creating the system image:","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"PackageCompiler.create_sysimage(:OhMyREPL; precompile_statements_file=\"ohmyrepl_precompile.jl\", replace_default=true)","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"Restart julia and start typing something. If everything went well you should see the typed text become highlighted with a significantly smaller delay than before creating the new system image","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"note: Note\nIf you want to go back to the default sysimage you can runPackageCompiler.restore_default_sysimage()","category":"page"},{"location":"devdocs/intro/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"devdocs/intro/#","page":"Introduction","title":"Introduction","text":"This part of the documentation contains a set of tutorials aimed to teach how PackageCompiler works internally. This is done by going through some examples of manually creating sysimages and apps, mostly from the command line. By knowing the internals of PackageCompiler you can more easily figure out root causes of problems and help others. The inner functionality of PackageCompiler is actually quite simple. There are a few julia commands and compiler invocations that everything is built around, the rest is mostly scaffolding.","category":"page"},{"location":"devdocs/intro/#","page":"Introduction","title":"Introduction","text":"Part 1 focuses on how to build a local system image to reduce package load times and reduce the latency that can occur when calling a function for the first time. Part 2 targets how to build an executable based on the custom sysimage so that it can be run without having to explicitly start a Julia session. Part 3 details how to bundle that executable together with the Julia libraries and other files needed so that the bundle can be sent to and run on a different system where Julia might not be installed. These functionalities are exposed from PackageCompiler as create_sysimage and create_app.","category":"page"},{"location":"devdocs/intro/#","page":"Introduction","title":"Introduction","text":"It should be noted that there is some usage of non-documented Julia functions and flags.  They have not been changed for quite a long time (and are unlikely to change too much in the future), but some care should be taken.","category":"page"},{"location":"#PackageCompiler-1","page":"Home","title":"PackageCompiler","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"PackageCompiler is a Julia package with two main purposes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Creating custom sysimages for reduced latency when working locally with packages that have high startup time.\nCreating \"apps\" which are a bundle of files including an executable that can be sent and run on other machines without Julia being installed on that machine.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The manual contains some uses of Linux commands like ls (dir in Windows) and cat but hopefully these commands are common enough that the points still come across.","category":"page"},{"location":"#Installation-instructions-1","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nIt is strongly recommended to use the official binaries that are downloaded from  https://julialang.org/downloads/. Distribution-provided Julia installations are unlikely to work properly with this package.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To use PackageCompiler a C-compiler needs to be available:","category":"page"},{"location":"#macOS,-Linux-1","page":"Home","title":"macOS, Linux","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Having a decently modern gcc or clang available should be enough to use PackageCompiler on Linux or macOS. For macOS, using something like homebrew and for Linux the system package manager should work fine.","category":"page"},{"location":"#Windows-1","page":"Home","title":"Windows","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A suitable compiler will be automatically installed the first time it is needed.","category":"page"},{"location":"#Upgrading-from-pre-1.0-PackageCompiler-1","page":"Home","title":"Upgrading from pre 1.0 PackageCompiler","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There are some notes to facilitate upgrading from the earlier version of PackageCompiler here","category":"page"}]
}
