<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Apps · PackageCompiler</title><meta name="title" content="Apps · PackageCompiler"/><meta property="og:title" content="Apps · PackageCompiler"/><meta property="twitter:title" content="Apps · PackageCompiler"/><meta name="description" content="Documentation for PackageCompiler."/><meta property="og:description" content="Documentation for PackageCompiler."/><meta property="twitter:description" content="Documentation for PackageCompiler."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PackageCompiler</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="sysimages.html">Sysimages</a></li><li class="is-active"><a class="tocitem" href="apps.html">Apps</a><ul class="internal"><li><a class="tocitem" href="#Creating-an-app"><span>Creating an app</span></a></li><li><a class="tocitem" href="#relocatability"><span>Relocatability</span></a></li></ul></li><li><a class="tocitem" href="libs.html">Libraries</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/ohmyrepl.html">Creating a sysimage with OhMyREPL</a></li><li><a class="tocitem" href="examples/plots.html">Creating a sysimage for fast plotting with Plots.jl</a></li></ul></li><li><a class="tocitem" href="refs.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="apps.html">Apps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="apps.html">Apps</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/PackageCompiler.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/PackageCompiler.jl/blob/master/docs/src/apps.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="apps"><a class="docs-heading-anchor" href="#apps">Apps</a><a id="apps-1"></a><a class="docs-heading-anchor-permalink" href="#apps" title="Permalink"></a></h1><p>With an &quot;app&quot; we here mean a &quot;bundle&quot; of files where one of these files is an executable and where this bundle can be sent to another machine while still allowing the executable to run.</p><p>Use-cases for Julia-apps are for example when one wants to provide some kind of functionality where the fact that the code was written in Julia is just an implementation detail and where requiring the user to download and use Julia to run the code would be a distraction. There is also no need to provide the original Julia source code for apps since everything gets baked into the sysimage.</p><h2 id="Creating-an-app"><a class="docs-heading-anchor" href="#Creating-an-app">Creating an app</a><a id="Creating-an-app-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-app" title="Permalink"></a></h2><p>The source of an app is a package with a project and manifest file. You can easily create this using the package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.generate(&quot;MyApp&quot;)</code></pre><p>In the code for the package, there should be a function with the signature</p><pre><code class="language-julia hljs">function julia_main()::Cint
  # do something based on ARGS?
  return 0 # if things finished successfully
end</code></pre><p>defined (<a href="apps.html#multiple">you can customize this</a>), which will be the entry point of the app (the function that runs when the executable in the app is run). A skeleton of an app to start working from can be found <a href="https://github.com/JuliaLang/PackageCompiler.jl/tree/master/examples/MyApp">here</a>.</p><p>The app is then compiled using the <a href="refs.html#PackageCompiler.create_app"><code>create_app</code></a> function that takes a path to the source code of the app and the destination where the app should be compiled to. This will bundle all required libraries for the app to run on another machine where the same Julia that created the app can run.  As an example, in the code snippet below, the example app linked above is compiled and run:</p><pre><code class="nohighlight hljs">~/PackageCompiler.jl/examples
❯ julia -q --project

julia&gt; using PackageCompiler

julia&gt; create_app(&quot;MyApp&quot;, &quot;MyAppCompiled&quot;)
[ Info: PackageCompiler: creating base system image (incremental=false), this might take a while...
[ Info: PackageCompiler: creating system image object file, this might take a while...

julia&gt; exit()

~/PackageCompiler.jl/examples
❯ MyAppCompiled/bin/MyApp foo bar --julia-args -t4
ARGS = [&quot;foo&quot;, &quot;bar&quot;]
Base.PROGRAM_FILE = &quot;./bin/MyApp&quot;
DEPOT_PATH = [&quot;/home/kc/JuliaPkgs/PackageCompiler.jl/MyAppCompiled/share/julia&quot;]
...
Running the artifact
The result of 2*5^2 - 10 == 40.000000</code></pre><p>Note that the arguments passed to the executable are available in the global variable <code>ARGS</code>. Standard julia arguments (like how many threads should be used) are passed in after the <code>--julia-args</code> argument.</p><p>The resulting executable is found in the <code>bin</code> folder in the compiled app directory.  The compiled app directory <code>MyAppCompiled</code> could now be put into an archive and sent to another machine or an installer could be wrapped around the directory, perhaps providing a better user experience than just an archive of files.</p><h3 id="Compilation-of-functions"><a class="docs-heading-anchor" href="#Compilation-of-functions">Compilation of functions</a><a id="Compilation-of-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Compilation-of-functions" title="Permalink"></a></h3><p>In the same way as <a href="sysimages.html#tracing">files for precompilation could be given when creating sysimages</a>, the same keyword arguments are used to add precompilation to apps.</p><h3 id="Incremental-vs-non-incremental-sysimage"><a class="docs-heading-anchor" href="#Incremental-vs-non-incremental-sysimage">Incremental vs non-incremental sysimage</a><a id="Incremental-vs-non-incremental-sysimage-1"></a><a class="docs-heading-anchor-permalink" href="#Incremental-vs-non-incremental-sysimage" title="Permalink"></a></h3><p>In the section about creating sysimages, there was a short discussion about incremental vs non-incremental sysimages. In short, an incremental sysimage is built on top of another sysimage, while a non-incremental is created from scratch. For sysimages, it makes sense to use an incremental sysimage built on top of Julia&#39;s default sysimage since we wanted the benefit of having a responsive REPL that it provides.  For apps, this is no longer the case, the sysimage is not meant to be used when working interactively, it only needs to be specialized for the specific app.  Therefore, by default, <code>incremental=false</code> is used for <code>create_app</code>. If, for some reason, one wants an incremental sysimage, <code>incremental=true</code> could be passed to <code>create_app</code>. With the example app, a non-incremental sysimage is about 70MB smaller than the default sysimage.</p><h3 id="Filtering-stdlibs"><a class="docs-heading-anchor" href="#Filtering-stdlibs">Filtering stdlibs</a><a id="Filtering-stdlibs-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-stdlibs" title="Permalink"></a></h3><p>By default, all standard libraries are included in the sysimage. It is possible to only include those standard libraries that the project needs.  This is done by passing the keyword argument <code>filter_stdlibs=true</code> to <code>create_app</code>. This causes the sysimage to be smaller, and possibly load faster. The reason this is not the default is that it is possible to &quot;accidentally&quot; depend on a standard library without it being reflected in the Project file. For example, it is possible to call <code>rand()</code> from a package without depending on Random, even though that is where the method is defined. If Random was excluded from the sysimage that call would then error. As another example, matrix multiplication, <code>rand(3,3) * rand(3,3)</code> requires both the standard libraries <code>LinearAlgebra</code> and <code>Random</code> This is because these standard libraries practice <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">&quot;type-piracy&quot;</a>,  just loading those packages can cause code to change behavior.</p><p>Nevertheless, the option is there to use. Just make sure to properly test the app with the resulting sysimage.</p><h3 id="multiple"><a class="docs-heading-anchor" href="#multiple">Multiple executables</a><a id="multiple-1"></a><a class="docs-heading-anchor-permalink" href="#multiple" title="Permalink"></a></h3><p>By default, the binary in the <code>bin</code> directory takes the name of the project, as defined in <code>Project.toml</code> and the julia function that will be called when running it is <code>julia_main</code>. You can change the executable name and the julia function using the <code>executables</code> keyword argument to <code>create_app</code>. As an example, if you want to have two executables called <code>A</code> and <code>B</code> calling the julia functions <code>main_A</code> and <code>main_B</code>, respectively, you would pass <code>executables= [&quot;A&quot; =&gt; &quot;main_A&quot;, &quot;B&quot; =&gt; &quot;main_B&quot;]</code>.  Note that <code>main_A</code> and <code>main_B</code> both need to not take any arguments and be annotated to return a <code>Cint</code>, for example:</p><pre><code class="language-jl hljs">function main_A()::Cint
    ...
end</code></pre><h2 id="relocatability"><a class="docs-heading-anchor" href="#relocatability">Relocatability</a><a id="relocatability-1"></a><a class="docs-heading-anchor-permalink" href="#relocatability" title="Permalink"></a></h2><p>Since we want to send the app to other machines the app we create must be &quot;relocatable&quot;.  With an app being relocatable we mean it does not rely on specifics of the machine where the app was created.  Relocatability is not an absolute measure, most apps assume some properties of the machine they will run on, like what operating system is installed and the presence of graphics drivers if one wants to show graphics. On the other hand, embedding things into the app that is most likely unique to the machine, such as absolute paths to libraries, means that the application almost surely will not run properly on another machine.</p><p>For something to be relocatable, everything that it depends on must also be relocatable.  In the case of an app, the app itself and all the Julia packages it depends on must also relocatable. This is a bit of an issue because the Julia package ecosystem has rarely given much thought to relocatability since creating &quot;apps&quot; has not been common.</p><p>The main problem with relocatability of Julia packages is that many packages are encoding fundamentally non-relocatable information <em>into the source code</em>. As an example, many packages tend to use a <code>build.jl</code> file (which runs when the package is first installed) that looks something like:</p><pre><code class="language-julia hljs">lib_path = find_library(&quot;libfoo&quot;)
write(&quot;deps.jl&quot;, &quot;const LIBFOO_PATH = $(repr(lib_path))&quot;)</code></pre><p>The main package file then contains:</p><pre><code class="language-julia hljs">module Package

if !isfile(&quot;../build/deps.jl&quot;)
    error(&quot;run Pkg.build(\&quot;Package\&quot;) to re-build Package&quot;)
end
include(&quot;../build/deps.jl&quot;)
function __init__()
    libfoo = Libdl.dlopen(LIBFOO_PATH)
end

...

end # module</code></pre><p>The absolute path to <code>lib_path</code> that <code>find_library</code> found is thus effectively included into the source code of the package. Arguably, the whole build system in Julia is inherently non-relocatable because it runs when the package is being installed which is a concept that does not make sense when distributing an app.</p><p>Some packages do need to call into external libraries and use external binaries so the question then arises: &quot;how are these packages supposed to do this in a relocatable way?&quot;  The answer is to use the &quot;artifact system&quot; introduced in Julia 1.3, and described in the following <a href="https://julialang.org/blog/2019/11/artifacts">blog post</a>. The artifact system is a declarative way of downloading and using &quot;external files&quot; like binaries and libraries.  How this is used in practice is described later. Another useful tool is the Julia package <a href="https://github.com/JuliaPackaging/RelocatableFolders.jl">RelocatableFolders.jl</a>.</p><h3 id="Artifacts"><a class="docs-heading-anchor" href="#Artifacts">Artifacts</a><a id="Artifacts-1"></a><a class="docs-heading-anchor-permalink" href="#Artifacts" title="Permalink"></a></h3><p>The way to depend on external libraries or binaries when creating apps is by using the <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/">artifact system</a>. PackageCompiler will bundle all artifacts needed by the project, and set up things so that they can be found during runtime on other machines.</p><p>The example app uses the artifact system to depend on a very simple toy binary that does some simple arithmetic. It is instructive to see how the <a href="https://github.com/JuliaLang/PackageCompiler.jl/blob/master/examples/MyApp/Artifacts.toml">artifact file</a> is <a href="https://github.com/JuliaLang/PackageCompiler.jl/blob/d722a3d91abe328ebd239e2f45660be35263ebe1/examples/MyApp/src/MyApp.jl#L7-L8">used in the source</a>.</p><h3 id="app-preferences"><a class="docs-heading-anchor" href="#app-preferences">Preferences</a><a id="app-preferences-1"></a><a class="docs-heading-anchor-permalink" href="#app-preferences" title="Permalink"></a></h3><p>Compile-time preferences used by any of the packages included in the app will be stored in the sysimage. To support runtime preferences, all preferences that the app &quot;sees&quot; during the compilation process are stored in the app bundle under <code>&lt;app_dir&gt;/share/julia/LocalPreferences.toml</code>. Note that preferences loaded at compile time are <em>not</em> affected by the values in the <code>LocalPreferences.toml</code>, but modifying the file <em>will</em> change the value of preferences loaded at runtime.</p><p>To learn more about compile time preferences and runtime preferences, please refer to the <a href="https://juliapackaging.github.io/Preferences.jl/stable/">Preferences.jl docs</a>.</p><h3 id="Reverse-engineering-the-compiled-app"><a class="docs-heading-anchor" href="#Reverse-engineering-the-compiled-app">Reverse engineering the compiled app</a><a id="Reverse-engineering-the-compiled-app-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse-engineering-the-compiled-app" title="Permalink"></a></h3><p>While the created app is relocatable and no source code is bundled with it, there are still some things about the build machine and the source code that can be &quot;reverse engineered&quot;.</p><h4 id="Absolute-paths-of-the-build-machine"><a class="docs-heading-anchor" href="#Absolute-paths-of-the-build-machine">Absolute paths of the build machine</a><a id="Absolute-paths-of-the-build-machine-1"></a><a class="docs-heading-anchor-permalink" href="#Absolute-paths-of-the-build-machine" title="Permalink"></a></h4><p>Julia records the paths and line-numbers for methods when they are getting compiled.  These get cached into the sysimage and can be found e.g. by dumping all strings in the sysimage:</p><pre><code class="nohighlight hljs">~/PackageCompiler.jl/examples/MyAppCompiled/bin
❯ strings MyApp.so | grep MyApp
MyApp
/home/kc/PackageCompiler.jl/examples/MyApp/
MyApp
/home/kc/PackageCompiler.jl/examples/MyApp/src/MyApp.jl
/home/kc/PackageCompiler.jl/examples/MyApp/src
MyApp.jl
/home/kc/PackageCompiler.jl/examples/MyApp/src/MyApp.jl</code></pre><p>This is a problem that the Julia standard libraries themselves have:</p><pre><code class="language-julia-repl hljs">julia&gt; @which rand()
rand() in Random at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/1.7/Random/src/Random.jl:256</code></pre><h4 id="Using-reflection-and-finding-lowered-code"><a class="docs-heading-anchor" href="#Using-reflection-and-finding-lowered-code">Using reflection and finding lowered code</a><a id="Using-reflection-and-finding-lowered-code-1"></a><a class="docs-heading-anchor-permalink" href="#Using-reflection-and-finding-lowered-code" title="Permalink"></a></h4><p>There is nothing preventing someone from starting Julia with the sysimage that comes with the app. In fact, to support distributed computing that needs to start up new Julia processes, there is also a <code>julia</code> executable in the <code>bin</code> folder that uses the custom sysimage. While the source code is not available one can read the &quot;lowered code&quot; and use reflection to find things like the name of fields in structs and global variables etc:</p><pre><code class="language-julia-repl hljs">~/PackageCompiler.jl/examples/MyAppCompiled/bin
❯ ./julia -q

julia&gt; names(MyApp; all=true)
18-element Vector{Symbol}:
 Symbol(&quot;#1#3&quot;)
 Symbol(&quot;#2#4&quot;)
 Symbol(&quot;#eval&quot;)
 Symbol(&quot;#fooifier_path&quot;)
 Symbol(&quot;#include&quot;)
 Symbol(&quot;#is_crayons_loaded&quot;)
 Symbol(&quot;#julia_main&quot;)
 Symbol(&quot;#real_main&quot;)
 :MyApp
 :eval
 :fooifier_path
 :include
 :is_crayons_loaded
 :julia_main
 :myrand
 :o
 :outputo
 :real_main

julia&gt; @code_lowered MyApp.real_main()
CodeInfo(
1 ─        Core.NewvarNode(:(#2))
│          Core.NewvarNode(:(n))
│   %3   = MyApp.ARGS
│          value@_17 = %3
│   %5   = Base.repr(%3)
│          Base.println(&quot;ARGS = &quot;, %5)
│          value@_17
│   %8   = Base.PROGRAM_FILE
│          value@_16 = %8
│   %10  = Base.repr(%8)
...</code></pre><h4 id="Preferences-in-app_dir/share/julia"><a class="docs-heading-anchor" href="#Preferences-in-app_dir/share/julia">Preferences in <code>&lt;app_dir&gt;/share/julia</code></a><a id="Preferences-in-app_dir/share/julia-1"></a><a class="docs-heading-anchor-permalink" href="#Preferences-in-app_dir/share/julia" title="Permalink"></a></h4><p>As described <a href="apps.html#app-preferences">above</a>, a TOML file with all preferences active during the compilation process will be stored with the app bundle. If your preferences may contain confidential information, you can either delete the <code>&lt;app_dir&gt;/share/julia/LocalPreferences.toml</code> file before distributing the app bundle, or suppress the preference file generation by passing <code>include_preferences=false</code> to <code>create_app</code>. Note, however, that if the preference file is not present, any preference loaded in your app at <em>runtime</em> will use their default value (or crash, if no default is provided).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="sysimages.html">« Sysimages</a><a class="docs-footer-nextpage" href="libs.html">Libraries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 22 August 2025 07:34">Friday 22 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
